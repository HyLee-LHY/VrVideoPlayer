/**
 * Minified by jsDelivr using Terser v3.14.1.
 * Original file: /npm/three@0.117.1/examples/js/objects/Water2.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
console.warn("THREE.Water2: As part of the transition to ES6 Modules, the files in 'examples/js' were deprecated in May 2020 (r117) and will be deleted in December 2020 (r124). You can find more information about developing using ES6 Modules in https://threejs.org/docs/index.html#manual/en/introduction/Import-via-modules."),THREE.Water=function(e,t){THREE.Mesh.call(this,e),this.type="Water";var o=this,r=void 0!==(t=t||{}).color?new THREE.Color(t.color):new THREE.Color(16777215),a=t.textureWidth||512,i=t.textureHeight||512,l=t.clipBias||0,n=t.flowDirection||new THREE.Vector2(1,0),f=t.flowSpeed||.03,c=t.reflectivity||.02,u=t.scale||1,m=t.shader||THREE.Water.WaterShader,v=void 0!==t.encoding?t.encoding:THREE.LinearEncoding,s=new THREE.TextureLoader,p=t.flowMap||void 0,d=t.normalMap0||s.load("textures/water/Water_1_M_Normal.jpg"),E=t.normalMap1||s.load("textures/water/Water_2_M_Normal.jpg"),g=.15,x=.5*g,R=new THREE.Matrix4,y=new THREE.Clock;if(void 0!==THREE.Reflector)if(void 0!==THREE.Refractor){var h=new THREE.Reflector(e,{textureWidth:a,textureHeight:i,clipBias:l,encoding:v}),w=new THREE.Refractor(e,{textureWidth:a,textureHeight:i,clipBias:l,encoding:v});h.matrixAutoUpdate=!1,w.matrixAutoUpdate=!1,this.material=new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.fog,m.uniforms]),vertexShader:m.vertexShader,fragmentShader:m.fragmentShader,transparent:!0,fog:!0}),void 0!==p?(this.material.defines.USE_FLOWMAP="",this.material.uniforms.tFlowMap={type:"t",value:p}):this.material.uniforms.flowDirection={type:"v2",value:n},d.wrapS=d.wrapT=THREE.RepeatWrapping,E.wrapS=E.wrapT=THREE.RepeatWrapping,this.material.uniforms.tReflectionMap.value=h.getRenderTarget().texture,this.material.uniforms.tRefractionMap.value=w.getRenderTarget().texture,this.material.uniforms.tNormalMap0.value=d,this.material.uniforms.tNormalMap1.value=E,this.material.uniforms.color.value=r,this.material.uniforms.reflectivity.value=c,this.material.uniforms.textureMatrix.value=R,this.material.uniforms.config.value.x=0,this.material.uniforms.config.value.y=x,this.material.uniforms.config.value.z=x,this.material.uniforms.config.value.w=u,this.onBeforeRender=function(e,t,r){var a,i;!function(e){R.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),R.multiply(e.projectionMatrix),R.multiply(e.matrixWorldInverse),R.multiply(o.matrixWorld)}(r),a=y.getDelta(),(i=o.material.uniforms.config).value.x+=f*a,i.value.y=i.value.x+x,i.value.x>=g?(i.value.x=0,i.value.y=x):i.value.y>=g&&(i.value.y=i.value.y-g),o.visible=!1,h.matrixWorld.copy(o.matrixWorld),w.matrixWorld.copy(o.matrixWorld),h.onBeforeRender(e,t,r),w.onBeforeRender(e,t,r),o.visible=!0}}else console.error("THREE.Water: Required component THREE.Refractor not found.");else console.error("THREE.Water: Required component THREE.Reflector not found.")},THREE.Water.prototype=Object.create(THREE.Mesh.prototype),THREE.Water.prototype.constructor=THREE.Water,THREE.Water.WaterShader={uniforms:{color:{type:"c",value:null},reflectivity:{type:"f",value:0},tReflectionMap:{type:"t",value:null},tRefractionMap:{type:"t",value:null},tNormalMap0:{type:"t",value:null},tNormalMap1:{type:"t",value:null},textureMatrix:{type:"m4",value:null},config:{type:"v4",value:new THREE.Vector4}},vertexShader:["#include <common>","#include <fog_pars_vertex>","#include <logdepthbuf_pars_vertex>","uniform mat4 textureMatrix;","varying vec4 vCoord;","varying vec2 vUv;","varying vec3 vToEye;","void main() {","\tvUv = uv;","\tvCoord = textureMatrix * vec4( position, 1.0 );","\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );","\tvToEye = cameraPosition - worldPosition.xyz;","\tvec4 mvPosition =  viewMatrix * worldPosition;","\tgl_Position = projectionMatrix * mvPosition;","\t#include <logdepthbuf_vertex>","\t#include <fog_vertex>","}"].join("\n"),fragmentShader:["#include <common>","#include <fog_pars_fragment>","#include <logdepthbuf_pars_fragment>","uniform sampler2D tReflectionMap;","uniform sampler2D tRefractionMap;","uniform sampler2D tNormalMap0;","uniform sampler2D tNormalMap1;","#ifdef USE_FLOWMAP","\tuniform sampler2D tFlowMap;","#else","\tuniform vec2 flowDirection;","#endif","uniform vec3 color;","uniform float reflectivity;","uniform vec4 config;","varying vec4 vCoord;","varying vec2 vUv;","varying vec3 vToEye;","void main() {","\t#include <logdepthbuf_fragment>","\tfloat flowMapOffset0 = config.x;","\tfloat flowMapOffset1 = config.y;","\tfloat halfCycle = config.z;","\tfloat scale = config.w;","\tvec3 toEye = normalize( vToEye );","\tvec2 flow;","\t#ifdef USE_FLOWMAP","\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;","\t#else","\t\tflow = flowDirection;","\t#endif","\tflow.x *= - 1.0;","\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );","\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );","\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;","\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );","\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );","\tfloat theta = max( dot( toEye, normal ), 0.0 );","\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );","\tvec3 coord = vCoord.xyz / vCoord.w;","\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;","\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );","\tvec4 refractColor = texture2D( tRefractionMap, uv );","\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );","\t#include <tonemapping_fragment>","\t#include <encodings_fragment>","\t#include <fog_fragment>","}"].join("\n")};
//# sourceMappingURL=/sm/2d56af225d8a334a1535158ee472658c63fdce55d6d0a3a87759dd1e96f1fea2.map