/**
 * Minified by jsDelivr using Terser v3.14.1.
 * Original file: /npm/three@0.117.1/examples/js/utils/BufferGeometryUtils.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
console.warn("THREE.BufferGeometryUtils: As part of the transition to ES6 Modules, the files in 'examples/js' were deprecated in May 2020 (r117) and will be deleted in December 2020 (r124). You can find more information about developing using ES6 Modules in https://threejs.org/docs/index.html#manual/en/introduction/Import-via-modules."),THREE.BufferGeometryUtils={computeTangents:function(e){var r=e.index,t=e.attributes;if(null!==r&&void 0!==t.position&&void 0!==t.normal&&void 0!==t.uv){var o=r.array,i=t.position.array,n=t.normal.array,a=t.uv.array,u=i.length/3;void 0===t.tangent&&e.setAttribute("tangent",new THREE.BufferAttribute(new Float32Array(4*u),4));for(var s=t.tangent.array,f=[],l=[],m=0;m<u;m++)f[m]=new THREE.Vector3,l[m]=new THREE.Vector3;var g=new THREE.Vector3,d=new THREE.Vector3,c=new THREE.Vector3,E=new THREE.Vector2,h=new THREE.Vector2,b=new THREE.Vector2,y=new THREE.Vector3,v=new THREE.Vector3,p=e.groups;0===p.length&&(p=[{start:0,count:o.length}]);m=0;for(var T=p.length;m<T;++m)for(var w=M=(z=p[m]).start,A=M+z.count;w<A;w+=3)V(o[w+0],o[w+1],o[w+2]);var B,R,H,x=new THREE.Vector3,G=new THREE.Vector3,S=new THREE.Vector3,U=new THREE.Vector3;for(m=0,T=p.length;m<T;++m){var z,M;for(w=M=(z=p[m]).start,A=M+z.count;w<A;w+=3)D(o[w+0]),D(o[w+1]),D(o[w+2])}}else console.error("THREE.BufferGeometryUtils: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");function V(e,r,t){g.fromArray(i,3*e),d.fromArray(i,3*r),c.fromArray(i,3*t),E.fromArray(a,2*e),h.fromArray(a,2*r),b.fromArray(a,2*t),d.sub(g),c.sub(g),h.sub(E),b.sub(E);var o=1/(h.x*b.y-b.x*h.y);isFinite(o)&&(y.copy(d).multiplyScalar(b.y).addScaledVector(c,-h.y).multiplyScalar(o),v.copy(c).multiplyScalar(h.x).addScaledVector(d,-b.x).multiplyScalar(o),f[e].add(y),f[r].add(y),f[t].add(y),l[e].add(v),l[r].add(v),l[t].add(v))}function D(e){S.fromArray(n,3*e),U.copy(S),R=f[e],x.copy(R),x.sub(S.multiplyScalar(S.dot(R))).normalize(),G.crossVectors(U,R),H=G.dot(l[e]),B=H<0?-1:1,s[4*e]=x.x,s[4*e+1]=x.y,s[4*e+2]=x.z,s[4*e+3]=B}},mergeBufferGeometries:function(e,r){for(var t=null!==e[0].index,o=new Set(Object.keys(e[0].attributes)),i=new Set(Object.keys(e[0].morphAttributes)),n={},a={},u=e[0].morphTargetsRelative,s=new THREE.BufferGeometry,f=0,l=0;l<e.length;++l){var m=e[l],g=0;if(t!==(null!==m.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+l+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(var d in m.attributes){if(!o.has(d))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+l+'. All geometries must have compatible attributes; make sure "'+d+'" attribute exists among all geometries, or in none of them.'),null;void 0===n[d]&&(n[d]=[]),n[d].push(m.attributes[d]),g++}if(g!==o.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+l+". Make sure all geometries have the same number of attributes."),null;if(u!==m.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+l+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(var d in m.morphAttributes){if(!i.has(d))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+l+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===a[d]&&(a[d]=[]),a[d].push(m.morphAttributes[d])}if(s.userData.mergedUserData=s.userData.mergedUserData||[],s.userData.mergedUserData.push(m.userData),r){var c;if(t)c=m.index.count;else{if(void 0===m.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+l+". The geometry must have either an index or a position attribute"),null;c=m.attributes.position.count}s.addGroup(f,c,l),f+=c}}if(t){var E=0,h=[];for(l=0;l<e.length;++l){for(var b=e[l].index,y=0;y<b.count;++y)h.push(b.getX(y)+E);E+=e[l].attributes.position.count}s.setIndex(h)}for(var d in n){var v=this.mergeBufferAttributes(n[d]);if(!v)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+d+" attribute."),null;s.setAttribute(d,v)}for(var d in a){var p=a[d][0].length;if(0===p)break;s.morphAttributes=s.morphAttributes||{},s.morphAttributes[d]=[];for(l=0;l<p;++l){var T=[];for(y=0;y<a[d].length;++y)T.push(a[d][y][l]);var w=this.mergeBufferAttributes(T);if(!w)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+d+" morphAttribute."),null;s.morphAttributes[d].push(w)}}return s},mergeBufferAttributes:function(e){for(var r,t,o,i=0,n=0;n<e.length;++n){var a=e[n];if(a.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===r&&(r=a.array.constructor),r!==a.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===t&&(t=a.itemSize),t!==a.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===o&&(o=a.normalized),o!==a.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;i+=a.array.length}var u=new r(i),s=0;for(n=0;n<e.length;++n)u.set(e[n].array,s),s+=e[n].array.length;return new THREE.BufferAttribute(u,t,o)},interleaveAttributes:function(e){for(var r,t=0,o=0,i=0,n=e.length;i<n;++i){var a=e[i];if(void 0===r&&(r=a.array.constructor),r!==a.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;t+=a.array.length,o+=a.itemSize}var u=new THREE.InterleavedBuffer(new r(t),o),s=0,f=[],l=["getX","getY","getZ","getW"],m=["setX","setY","setZ","setW"],g=0;for(n=e.length;g<n;g++){var d=(a=e[g]).itemSize,c=a.count,E=new THREE.InterleavedBufferAttribute(u,d,s,a.normalized);f.push(E),s+=d;for(var h=0;h<c;h++)for(var b=0;b<d;b++)E[m[b]](h,a[l[b]](h))}return f},estimateBytesUsed:function(e){var r=0;for(var t in e.attributes){var o=e.getAttribute(t);r+=o.count*o.itemSize*o.array.BYTES_PER_ELEMENT}var i=e.getIndex();return r+=i?i.count*i.itemSize*i.array.BYTES_PER_ELEMENT:0},mergeVertices:function(e,r=1e-4){r=Math.max(r,Number.EPSILON);for(var t={},o=e.getIndex(),i=e.getAttribute("position"),n=o?o.count:i.count,a=0,u=Object.keys(e.attributes),s={},f={},l=[],m=["getX","getY","getZ","getW"],g=0,d=u.length;g<d;g++){s[v=u[g]]=[],(A=e.morphAttributes[v])&&(f[v]=new Array(A.length).fill().map(()=>[]))}var c=Math.log10(1/r),E=Math.pow(10,c);for(g=0;g<n;g++){var h=o?o.getX(g):g,b="",y=0;for(d=u.length;y<d;y++)for(var v=u[y],p=(w=e.getAttribute(v)).itemSize,T=0;T<p;T++)b+=`${~~(w[m[T]](h)*E)},`;if(b in t)l.push(t[b]);else{for(y=0,d=u.length;y<d;y++){v=u[y];var w=e.getAttribute(v),A=e.morphAttributes[v],B=(p=w.itemSize,s[v]),R=f[v];for(T=0;T<p;T++){var H=m[T];if(B.push(w[H](h)),A)for(var x=0,G=A.length;x<G;x++)R[x].push(A[x][H](h))}}t[b]=a,l.push(a),a++}}const S=e.clone();for(g=0,d=u.length;g<d;g++){v=u[g];var U=e.getAttribute(v),z=new U.array.constructor(s[v]);w=new THREE.BufferAttribute(z,U.itemSize,U.normalized);if(S.setAttribute(v,w),v in f)for(y=0;y<f[v].length;y++){var M=e.morphAttributes[v][y],V=(z=new M.array.constructor(f[v][y]),new THREE.BufferAttribute(z,M.itemSize,M.normalized));S.morphAttributes[v][y]=V}}return S.setIndex(l),S},toTrianglesDrawMode:function(e,r){if(r===THREE.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(r===THREE.TriangleFanDrawMode||r===THREE.TriangleStripDrawMode){var t=e.getIndex();if(null===t){var o=[],i=e.getAttribute("position");if(void 0===i)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(var n=0;n<i.count;n++)o.push(n);e.setIndex(o),t=e.getIndex()}var a=t.count-2,u=[];if(r===THREE.TriangleFanDrawMode)for(n=1;n<=a;n++)u.push(t.getX(0)),u.push(t.getX(n)),u.push(t.getX(n+1));else for(n=0;n<a;n++)n%2==0?(u.push(t.getX(n)),u.push(t.getX(n+1)),u.push(t.getX(n+2))):(u.push(t.getX(n+2)),u.push(t.getX(n+1)),u.push(t.getX(n)));u.length/3!==a&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");var s=e.clone();return s.setIndex(u),s.clearGroups(),s}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",r),e}};
//# sourceMappingURL=/sm/20371e26463e7b6ca027c8390612aa07c9bd2b526a0fc1522e72e63fe9d053d0.map