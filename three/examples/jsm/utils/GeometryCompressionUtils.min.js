/**
 * Minified by jsDelivr using Terser v3.14.1.
 * Original file: /npm/three@0.117.1/examples/jsm/utils/GeometryCompressionUtils.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{BufferAttribute,Matrix3,Matrix4,MeshPhongMaterial,ShaderChunk,ShaderLib,UniformsUtils,Vector3}from"../../../build/three.module.js";var GeometryCompressionUtils={compressNormals:function(e,t){e.geometry||console.error("Mesh must contain geometry. ");let n=e.geometry.attributes.normal;if(n||console.error("Geometry must contain normal attribute. "),n.isPacked)return;3!=n.itemSize&&console.error("normal.itemSize is not 3, which cannot be encoded. ");let r,a=n.array,o=n.count;if("DEFAULT"==t){r=new Uint8Array(3*o);for(let e=0;e<a.length;e+=3){let t;t=this.EncodingFuncs.defaultEncode(a[e],a[e+1],a[e+2],1),r[e+0]=t[0],r[e+1]=t[1],r[e+2]=t[2]}e.geometry.setAttribute("normal",new BufferAttribute(r,3,!0)),e.geometry.attributes.normal.bytes=1*r.length}else if("OCT1Byte"==t){r=new Int8Array(2*o);for(let e=0;e<a.length;e+=3){let t;t=this.EncodingFuncs.octEncodeBest(a[e],a[e+1],a[e+2],1),r[e/3*2+0]=t[0],r[e/3*2+1]=t[1]}e.geometry.setAttribute("normal",new BufferAttribute(r,2,!0)),e.geometry.attributes.normal.bytes=1*r.length}else if("OCT2Byte"==t){r=new Int16Array(2*o);for(let e=0;e<a.length;e+=3){let t;t=this.EncodingFuncs.octEncodeBest(a[e],a[e+1],a[e+2],2),r[e/3*2+0]=t[0],r[e/3*2+1]=t[1]}e.geometry.setAttribute("normal",new BufferAttribute(r,2,!0)),e.geometry.attributes.normal.bytes=2*r.length}else if("ANGLES"==t){r=new Uint16Array(2*o);for(let e=0;e<a.length;e+=3){let t;t=this.EncodingFuncs.anglesEncode(a[e],a[e+1],a[e+2]),r[e/3*2+0]=t[0],r[e/3*2+1]=t[1]}e.geometry.setAttribute("normal",new BufferAttribute(r,2,!0)),e.geometry.attributes.normal.bytes=2*r.length}else console.error("Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. ");e.geometry.attributes.normal.needsUpdate=!0,e.geometry.attributes.normal.isPacked=!0,e.geometry.attributes.normal.packingMethod=t,e.material instanceof PackedPhongMaterial||(e.material=(new PackedPhongMaterial).copy(e.material)),"ANGLES"==t&&(e.material.defines.USE_PACKED_NORMAL=0),"OCT1Byte"==t&&(e.material.defines.USE_PACKED_NORMAL=1),"OCT2Byte"==t&&(e.material.defines.USE_PACKED_NORMAL=1),"DEFAULT"==t&&(e.material.defines.USE_PACKED_NORMAL=2)},compressPositions:function(e){e.geometry||console.error("Mesh must contain geometry. ");let t=e.geometry.attributes.position;if(t||console.error("Geometry must contain position attribute. "),t.isPacked)return;3!=t.itemSize&&console.error("position.itemSize is not 3, which cannot be packed. ");let n=t.array,r=this.EncodingFuncs.quantizedEncode(n,2),a=r.quantized,o=r.decodeMat;null==e.geometry.boundingBox&&e.geometry.computeBoundingBox(),null==e.geometry.boundingSphere&&e.geometry.computeBoundingSphere(),e.geometry.setAttribute("position",new BufferAttribute(a,3)),e.geometry.attributes.position.isPacked=!0,e.geometry.attributes.position.needsUpdate=!0,e.geometry.attributes.position.bytes=2*a.length,e.material instanceof PackedPhongMaterial||(e.material=(new PackedPhongMaterial).copy(e.material)),e.material.defines.USE_PACKED_POSITION=0,e.material.uniforms.quantizeMatPos.value=o,e.material.uniforms.quantizeMatPos.needsUpdate=!0},compressUvs:function(e){e.geometry||console.error("Mesh must contain geometry property. ");let t=e.geometry.attributes.uv;if(t||console.error("Geometry must contain uv attribute. "),t.isPacked)return;let n,r={min:1/0,max:-1/0},a=t.array;for(let e=0;e<a.length;e++)r.min=Math.min(r.min,a[e]),r.max=Math.max(r.max,a[e]);if(r.min>=-1&&r.max<=1){n=new Uint16Array(a.length);for(let e=0;e<a.length;e+=2){let t=this.EncodingFuncs.defaultEncode(a[e],a[e+1],0,2);n[e]=t[0],n[e+1]=t[1]}e.geometry.setAttribute("uv",new BufferAttribute(n,2,!0)),e.geometry.attributes.uv.isPacked=!0,e.geometry.attributes.uv.needsUpdate=!0,e.geometry.attributes.uv.bytes=2*n.length,e.material instanceof PackedPhongMaterial||(e.material=(new PackedPhongMaterial).copy(e.material)),e.material.defines.USE_PACKED_UV=0}else n=this.EncodingFuncs.quantizedEncodeUV(a,2),e.geometry.setAttribute("uv",new BufferAttribute(n.quantized,2)),e.geometry.attributes.uv.isPacked=!0,e.geometry.attributes.uv.needsUpdate=!0,e.geometry.attributes.uv.bytes=2*n.quantized.length,e.material instanceof PackedPhongMaterial||(e.material=(new PackedPhongMaterial).copy(e.material)),e.material.defines.USE_PACKED_UV=1,e.material.uniforms.quantizeMatUV.value=n.decodeMat,e.material.uniforms.quantizeMatUV.needsUpdate=!0},EncodingFuncs:{defaultEncode:function(e,t,n,r){if(1==r){let r=Math.round(.5*(e+1)*255),a=Math.round(.5*(t+1)*255),o=Math.round(.5*(n+1)*255);return new Uint8Array([r,a,o])}if(2==r){let r=Math.round(.5*(e+1)*65535),a=Math.round(.5*(t+1)*65535),o=Math.round(.5*(n+1)*65535);return new Uint16Array([r,a,o])}console.error("number of bytes must be 1 or 2")},defaultDecode:function(e,t){return 1==t?[e[0]/255*2-1,e[1]/255*2-1,e[2]/255*2-1]:2==t?[e[0]/65535*2-1,e[1]/65535*2-1,e[2]/65535*2-1]:void console.error("number of bytes must be 1 or 2")},anglesEncode:function(e,t,n){let r=parseInt(.5*(1+Math.atan2(t,e)/Math.PI)*65535),a=parseInt(.5*(1+n)*65535);return new Uint16Array([r,a])},octEncodeBest:function(e,t,n,r){var a,o,i,h,s;return i=a=d(e,t,n,"floor","floor"),o=u(a),s=m(e,t,n,o),o=u(a=d(e,t,n,"ceil","floor")),(h=m(e,t,n,o))>s&&(i=a,s=h),o=u(a=d(e,t,n,"floor","ceil")),(h=m(e,t,n,o))>s&&(i=a,s=h),o=u(a=d(e,t,n,"ceil","ceil")),(h=m(e,t,n,o))>s&&(i=a),i;function d(e,t,a,o,i){var h=e/(Math.abs(e)+Math.abs(t)+Math.abs(a)),s=t/(Math.abs(e)+Math.abs(t)+Math.abs(a));if(n<0){var d=(1-Math.abs(s))*(h>=0?1:-1),u=(1-Math.abs(h))*(s>=0?1:-1);h=d,s=u;var m=1-Math.abs(h)-Math.abs(s);m>0&&(m+=.001,h+=h>0?m/2:-m/2,s+=s>0?m/2:-m/2)}return 1==r?new Int8Array([Math[o](127.5*h+(h<0?1:0)),Math[i](127.5*s+(s<0?1:0))]):2==r?new Int16Array([Math[o](32767.5*h+(h<0?1:0)),Math[i](32767.5*s+(s<0?1:0))]):void 0}function u(e){var t=e[0],n=e[1];1==r?(t/=t<0?127:128,n/=n<0?127:128):2==r&&(t/=t<0?32767:32768,n/=n<0?32767:32768);var a=1-Math.abs(t)-Math.abs(n);if(a<0){var o=t;t=(1-Math.abs(n))*(t>=0?1:-1),n=(1-Math.abs(o))*(n>=0?1:-1)}var i=Math.sqrt(t*t+n*n+a*a);return[t/i,n/i,a/i]}function m(e,t,n,r){return e*r[0]+t*r[1]+n*r[2]}},quantizedEncode:function(e,t){let n,r;1==t?(n=new Uint8Array(e.length),r=255):2==t?(n=new Uint16Array(e.length),r=65535):console.error("number of bytes error! ");let a=new Matrix4,o=new Float32Array(3),i=new Float32Array(3);o[0]=o[1]=o[2]=Number.MAX_VALUE,i[0]=i[1]=i[2]=-Number.MAX_VALUE;for(let t=0;t<e.length;t+=3)o[0]=Math.min(o[0],e[t+0]),o[1]=Math.min(o[1],e[t+1]),o[2]=Math.min(o[2],e[t+2]),i[0]=Math.max(i[0],e[t+0]),i[1]=Math.max(i[1],e[t+1]),i[2]=Math.max(i[2],e[t+2]);a.scale(new Vector3((i[0]-o[0])/r,(i[1]-o[1])/r,(i[2]-o[2])/r)),a.elements[12]=o[0],a.elements[13]=o[1],a.elements[14]=o[2],a.transpose();let h=new Float32Array([i[0]!==o[0]?r/(i[0]-o[0]):0,i[1]!==o[1]?r/(i[1]-o[1]):0,i[2]!==o[2]?r/(i[2]-o[2]):0]);for(let t=0;t<e.length;t+=3)n[t+0]=Math.floor((e[t+0]-o[0])*h[0]),n[t+1]=Math.floor((e[t+1]-o[1])*h[1]),n[t+2]=Math.floor((e[t+2]-o[2])*h[2]);return{quantized:n,decodeMat:a}},quantizedEncodeUV:function(e,t){let n,r;1==t?(n=new Uint8Array(e.length),r=255):2==t?(n=new Uint16Array(e.length),r=65535):console.error("number of bytes error! ");let a=new Matrix3,o=new Float32Array(2),i=new Float32Array(2);o[0]=o[1]=Number.MAX_VALUE,i[0]=i[1]=-Number.MAX_VALUE;for(let t=0;t<e.length;t+=2)o[0]=Math.min(o[0],e[t+0]),o[1]=Math.min(o[1],e[t+1]),i[0]=Math.max(i[0],e[t+0]),i[1]=Math.max(i[1],e[t+1]);a.scale((i[0]-o[0])/r,(i[1]-o[1])/r),a.elements[6]=o[0],a.elements[7]=o[1],a.transpose();let h=new Float32Array([i[0]!==o[0]?r/(i[0]-o[0]):0,i[1]!==o[1]?r/(i[1]-o[1]):0]);for(let t=0;t<e.length;t+=2)n[t+0]=Math.floor((e[t+0]-o[0])*h[0]),n[t+1]=Math.floor((e[t+1]-o[1])*h[1]);return{quantized:n,decodeMat:a}}}};function PackedPhongMaterial(e){MeshPhongMaterial.call(this),this.defines={},this.type="PackedPhongMaterial",this.uniforms=UniformsUtils.merge([ShaderLib.phong.uniforms,{quantizeMatPos:{value:null},quantizeMatUV:{value:null}}]),this.vertexShader=["#define PHONG","varying vec3 vViewPosition;","#ifndef FLAT_SHADED","varying vec3 vNormal;","#endif",ShaderChunk.common,ShaderChunk.uv_pars_vertex,ShaderChunk.uv2_pars_vertex,ShaderChunk.displacementmap_pars_vertex,ShaderChunk.envmap_pars_vertex,ShaderChunk.color_pars_vertex,ShaderChunk.fog_pars_vertex,ShaderChunk.morphtarget_pars_vertex,ShaderChunk.skinning_pars_vertex,ShaderChunk.shadowmap_pars_vertex,ShaderChunk.logdepthbuf_pars_vertex,ShaderChunk.clipping_planes_pars_vertex,"#ifdef USE_PACKED_NORMAL\n\t\t\t#if USE_PACKED_NORMAL == 0\n\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t{\n\t\t\t\t\tfloat x = packedNormal.x * 2.0 - 1.0;\n\t\t\t\t\tfloat y = packedNormal.y * 2.0 - 1.0;\n\t\t\t\t\tvec2 scth = vec2(sin(x * PI), cos(x * PI));\n\t\t\t\t\tvec2 scphi = vec2(sqrt(1.0 - y * y), y);\n\t\t\t\t\treturn normalize( vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y) );\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t\t#if USE_PACKED_NORMAL == 1\n\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t{\n\t\t\t\t\tvec3 v = vec3(packedNormal.xy, 1.0 - abs(packedNormal.x) - abs(packedNormal.y));\n\t\t\t\t\tif (v.z < 0.0)\n\t\t\t\t\t{\n\t\t\t\t\t\tv.xy = (1.0 - abs(v.yx)) * vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n\t\t\t\t\t}\n\t\t\t\t\treturn normalize(v);\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t\t#if USE_PACKED_NORMAL == 2\n\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t{\n\t\t\t\t\tvec3 v = (packedNormal * 2.0) - 1.0;\n\t\t\t\t\treturn normalize(v);\n\t\t\t\t}\n\t\t\t#endif\n\t\t#endif","#ifdef USE_PACKED_POSITION\n\t\t\t#if USE_PACKED_POSITION == 0\n\t\t\t\tuniform mat4 quantizeMatPos;\n\t\t\t#endif\n\t\t#endif","#ifdef USE_PACKED_UV\n\t\t\t#if USE_PACKED_UV == 1\n\t\t\t\tuniform mat3 quantizeMatUV;\n\t\t\t#endif\n\t\t#endif","#ifdef USE_PACKED_UV\n\t\t\t#if USE_PACKED_UV == 0\n\t\t\t\tvec2 decodeUV(vec2 packedUV)\n\t\t\t\t{\n\t\t\t\t\tvec2 uv = (packedUV * 2.0) - 1.0;\n\t\t\t\t\treturn uv;\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t\t#if USE_PACKED_UV == 1\n\t\t\t\tvec2 decodeUV(vec2 packedUV)\n\t\t\t\t{\n\t\t\t\t\tvec2 uv = ( vec3(packedUV, 1.0) * quantizeMatUV ).xy;\n\t\t\t\t\treturn uv;\n\t\t\t\t}\n\t\t\t#endif\n\t\t#endif","void main() {",ShaderChunk.uv_vertex,"#ifdef USE_UV\n\t\t\t#ifdef USE_PACKED_UV\n\t\t\t\tvUv = decodeUV(vUv);\n\t\t\t#endif\n\t\t#endif",ShaderChunk.uv2_vertex,ShaderChunk.color_vertex,ShaderChunk.beginnormal_vertex,"#ifdef USE_PACKED_NORMAL\n\t\t\tobjectNormal = decodeNormal(objectNormal);\n\t\t#endif\n\n\t\t#ifdef USE_TANGENT\n\t\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t\t#endif\n\t\t",ShaderChunk.morphnormal_vertex,ShaderChunk.skinbase_vertex,ShaderChunk.skinnormal_vertex,ShaderChunk.defaultnormal_vertex,"#ifndef FLAT_SHADED","\tvNormal = normalize( transformedNormal );","#endif",ShaderChunk.begin_vertex,"#ifdef USE_PACKED_POSITION\n\t\t\t#if USE_PACKED_POSITION == 0\n\t\t\t\ttransformed = ( vec4(transformed, 1.0) * quantizeMatPos ).xyz;\n\t\t\t#endif\n\t\t#endif",ShaderChunk.morphtarget_vertex,ShaderChunk.skinning_vertex,ShaderChunk.displacementmap_vertex,ShaderChunk.project_vertex,ShaderChunk.logdepthbuf_vertex,ShaderChunk.clipping_planes_vertex,"vViewPosition = - mvPosition.xyz;",ShaderChunk.worldpos_vertex,ShaderChunk.envmap_vertex,ShaderChunk.shadowmap_vertex,ShaderChunk.fog_vertex,"}"].join("\n"),this.fragmentShader=["#define PHONG","uniform vec3 diffuse;","uniform vec3 emissive;","uniform vec3 specular;","uniform float shininess;","uniform float opacity;",ShaderChunk.common,ShaderChunk.packing,ShaderChunk.dithering_pars_fragment,ShaderChunk.color_pars_fragment,ShaderChunk.uv_pars_fragment,ShaderChunk.uv2_pars_fragment,ShaderChunk.map_pars_fragment,ShaderChunk.alphamap_pars_fragment,ShaderChunk.aomap_pars_fragment,ShaderChunk.lightmap_pars_fragment,ShaderChunk.emissivemap_pars_fragment,ShaderChunk.envmap_common_pars_fragment,ShaderChunk.envmap_pars_fragment,ShaderChunk.cube_uv_reflection_fragment,ShaderChunk.fog_pars_fragment,ShaderChunk.bsdfs,ShaderChunk.lights_pars_begin,ShaderChunk.lights_phong_pars_fragment,ShaderChunk.shadowmap_pars_fragment,ShaderChunk.bumpmap_pars_fragment,ShaderChunk.normalmap_pars_fragment,ShaderChunk.specularmap_pars_fragment,ShaderChunk.logdepthbuf_pars_fragment,ShaderChunk.clipping_planes_pars_fragment,"void main() {",ShaderChunk.clipping_planes_fragment,"vec4 diffuseColor = vec4( diffuse, opacity );","ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );","vec3 totalEmissiveRadiance = emissive;",ShaderChunk.logdepthbuf_fragment,ShaderChunk.map_fragment,ShaderChunk.color_fragment,ShaderChunk.alphamap_fragment,ShaderChunk.alphatest_fragment,ShaderChunk.specularmap_fragment,ShaderChunk.normal_fragment_begin,ShaderChunk.normal_fragment_maps,ShaderChunk.emissivemap_fragment,ShaderChunk.lights_phong_fragment,ShaderChunk.lights_fragment_begin,ShaderChunk.lights_fragment_maps,ShaderChunk.lights_fragment_end,ShaderChunk.aomap_fragment,"vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;",ShaderChunk.envmap_fragment,"gl_FragColor = vec4( outgoingLight, diffuseColor.a );",ShaderChunk.tonemapping_fragment,ShaderChunk.encodings_fragment,ShaderChunk.fog_fragment,ShaderChunk.premultiplied_alpha_fragment,ShaderChunk.dithering_fragment,"}"].join("\n"),this.setValues(e)}PackedPhongMaterial.prototype=Object.create(MeshPhongMaterial.prototype);export{GeometryCompressionUtils,PackedPhongMaterial};
//# sourceMappingURL=/sm/aecf0ef15a9eb7702bd353becf9b88f4b4944cef877fdee5b9232bb5f18184c1.map