/**
 * Minified by jsDelivr using Terser v3.14.1.
 * Original file: /npm/three@0.117.1/examples/jsm/utils/RoughnessMipmapper.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{LinearMipMapLinearFilter,MathUtils,Mesh,NoBlending,OrthographicCamera,PlaneBufferGeometry,RawShaderMaterial,Vector2,WebGLRenderTarget}from"../../../build/three.module.js";var _mipmapMaterial=_getMipmapMaterial(),_mesh=new Mesh(new PlaneBufferGeometry(2,2),_mipmapMaterial),_flatCamera=new OrthographicCamera(0,1,0,1,0,1),_tempTarget=null,_renderer=null;function RoughnessMipmapper(e){(_renderer=e).compile(_mesh,_flatCamera)}function _getMipmapMaterial(){var e=new RawShaderMaterial({uniforms:{roughnessMap:{value:null},normalMap:{value:null},texelSize:{value:new Vector2(1,1)}},vertexShader:"\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4( position, 1.0 );\n}\n            ",fragmentShader:"\nprecision mediump float;\nprecision mediump int;\nvarying vec2 vUv;\nuniform sampler2D roughnessMap;\nuniform sampler2D normalMap;\nuniform vec2 texelSize;\n\n#define ENVMAP_TYPE_CUBE_UV\nvec4 envMapTexelToLinear(vec4 a){return a;}\n#include <cube_uv_reflection_fragment>\n\nfloat roughnessToVariance(float roughness) {\nfloat variance = 0.0;\nif (roughness >= r1) {\n  variance = (r0 - roughness) * (v1 - v0) / (r0 - r1) + v0;\n} else if (roughness >= r4) {\n  variance = (r1 - roughness) * (v4 - v1) / (r1 - r4) + v1;\n} else if (roughness >= r5) {\n  variance = (r4 - roughness) * (v5 - v4) / (r4 - r5) + v4;\n} else {\n  float roughness2 = roughness * roughness;\n  variance = 1.79 * roughness2 * roughness2;\n}\nreturn variance;\n}\nfloat varianceToRoughness(float variance) {\nfloat roughness = 0.0;\nif (variance >= v1) {\n  roughness = (v0 - variance) * (r1 - r0) / (v0 - v1) + r0;\n} else if (variance >= v4) {\n  roughness = (v1 - variance) * (r4 - r1) / (v1 - v4) + r1;\n} else if (variance >= v5) {\n  roughness = (v4 - variance) * (r5 - r4) / (v4 - v5) + r4;\n} else {\n  roughness = pow(0.559 * variance, 0.25);// 0.559 = 1.0 / 1.79\n}\nreturn roughness;\n}\n\nvoid main() {\n  gl_FragColor = texture2D(roughnessMap, vUv, -1.0);\n  if (texelSize.x == 0.0) return;\n  float roughness = gl_FragColor.g;\n  float variance = roughnessToVariance(roughness);\n  vec3 avgNormal;\n  for (float x = -1.0; x < 2.0; x += 2.0) {\n  for (float y = -1.0; y < 2.0; y += 2.0) {\n      vec2 uv = vUv + vec2(x, y) * 0.25 * texelSize;\n      avgNormal += normalize(texture2D(normalMap, uv, -1.0).xyz - 0.5);\n  }\n  }\n  variance += 1.0 - 0.25 * length(avgNormal);\n  gl_FragColor.g = varianceToRoughness(variance);\n}\n",blending:NoBlending,depthTest:!1,depthWrite:!1});return e.type="RoughnessMipmapper",e}RoughnessMipmapper.prototype={constructor:RoughnessMipmapper,generateMipmaps:function(e){var{roughnessMap:r,normalMap:a}=e;if(null!=r&&null!=a&&r.generateMipmaps&&!e.userData.roughnessUpdated){e.userData.roughnessUpdated=!0;var n=Math.max(r.image.width,a.image.width),t=Math.max(r.image.height,a.image.height);if(MathUtils.isPowerOfTwo(n)&&MathUtils.isPowerOfTwo(t)){var i=_renderer.getRenderTarget(),s=_renderer.autoClear;if(_renderer.autoClear=!1,null!=_tempTarget&&_tempTarget.width===n&&_tempTarget.height===t||(null!=_tempTarget&&_tempTarget.dispose(),(_tempTarget=new WebGLRenderTarget(n,t,{depthBuffer:!1,stencilBuffer:!1})).scissorTest=!0),n!==r.image.width||t!==r.image.height){var o=new WebGLRenderTarget(n,t,{minFilter:LinearMipMapLinearFilter,depthBuffer:!1,stencilBuffer:!1});o.texture.generateMipmaps=!0,_renderer.setRenderTarget(o),e.roughnessMap=o.texture,e.metalnessMap==r&&(e.metalnessMap=e.roughnessMap),e.aoMap==r&&(e.aoMap=e.roughnessMap)}_mipmapMaterial.uniforms.roughnessMap.value=r,_mipmapMaterial.uniforms.normalMap.value=a;for(var p=new Vector2(0,0),u=_mipmapMaterial.uniforms.texelSize.value,l=0;n>=1&&t>=1;++l,n/=2,t/=2)u.set(1/n,1/t),0==l&&u.set(0,0),_tempTarget.viewport.set(p.x,p.y,n,t),_tempTarget.scissor.set(p.x,p.y,n,t),_renderer.setRenderTarget(_tempTarget),_renderer.render(_mesh,_flatCamera),_renderer.copyFramebufferToTexture(p,e.roughnessMap,l),_mipmapMaterial.uniforms.roughnessMap.value=e.roughnessMap;r!==e.roughnessMap&&r.dispose(),_renderer.setRenderTarget(i),_renderer.autoClear=s}}},dispose:function(){_mipmapMaterial.dispose(),_mesh.geometry.dispose(),null!=_tempTarget&&_tempTarget.dispose()}};export{RoughnessMipmapper};
//# sourceMappingURL=/sm/eee57f9eb3b8444c19364e07e6861c9b8824eaac99e6ec7d26ba0c3ac5922b4a.map