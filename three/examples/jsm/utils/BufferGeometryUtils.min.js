/**
 * Minified by jsDelivr using Terser v3.14.1.
 * Original file: /npm/three@0.117.1/examples/jsm/utils/BufferGeometryUtils.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{BufferAttribute,BufferGeometry,InterleavedBuffer,InterleavedBufferAttribute,TriangleFanDrawMode,TriangleStripDrawMode,TrianglesDrawMode,Vector2,Vector3}from"../../../build/three.module.js";var BufferGeometryUtils={computeTangents:function(e){var r=e.index,t=e.attributes;if(null!==r&&void 0!==t.position&&void 0!==t.normal&&void 0!==t.uv){var o=r.array,i=t.position.array,a=t.normal.array,n=t.uv.array,u=i.length/3;void 0===t.tangent&&e.setAttribute("tangent",new BufferAttribute(new Float32Array(4*u),4));for(var s=t.tangent.array,f=[],l=[],m=0;m<u;m++)f[m]=new Vector3,l[m]=new Vector3;var g=new Vector3,c=new Vector3,d=new Vector3,h=new Vector2,b=new Vector2,v=new Vector2,y=new Vector3,p=new Vector3,B=e.groups;0===B.length&&(B=[{start:0,count:o.length}]);m=0;for(var A=B.length;m<A;++m)for(var w=D=(V=B[m]).start,E=D+V.count;w<E;w+=3)M(o[w+0],o[w+1],o[w+2]);var T,G,x,U=new Vector3,S=new Vector3,R=new Vector3,z=new Vector3;for(m=0,A=B.length;m<A;++m){var V,D;for(w=D=(V=B[m]).start,E=D+V.count;w<E;w+=3)H(o[w+0]),H(o[w+1]),H(o[w+2])}}else console.error("THREE.BufferGeometryUtils: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");function M(e,r,t){g.fromArray(i,3*e),c.fromArray(i,3*r),d.fromArray(i,3*t),h.fromArray(n,2*e),b.fromArray(n,2*r),v.fromArray(n,2*t),c.sub(g),d.sub(g),b.sub(h),v.sub(h);var o=1/(b.x*v.y-v.x*b.y);isFinite(o)&&(y.copy(c).multiplyScalar(v.y).addScaledVector(d,-b.y).multiplyScalar(o),p.copy(d).multiplyScalar(b.x).addScaledVector(c,-v.x).multiplyScalar(o),f[e].add(y),f[r].add(y),f[t].add(y),l[e].add(p),l[r].add(p),l[t].add(p))}function H(e){R.fromArray(a,3*e),z.copy(R),G=f[e],U.copy(G),U.sub(R.multiplyScalar(R.dot(G))).normalize(),S.crossVectors(z,G),x=S.dot(l[e]),T=x<0?-1:1,s[4*e]=U.x,s[4*e+1]=U.y,s[4*e+2]=U.z,s[4*e+3]=T}},mergeBufferGeometries:function(e,r){for(var t=null!==e[0].index,o=new Set(Object.keys(e[0].attributes)),i=new Set(Object.keys(e[0].morphAttributes)),a={},n={},u=e[0].morphTargetsRelative,s=new BufferGeometry,f=0,l=0;l<e.length;++l){var m=e[l],g=0;if(t!==(null!==m.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+l+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(var c in m.attributes){if(!o.has(c))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+l+'. All geometries must have compatible attributes; make sure "'+c+'" attribute exists among all geometries, or in none of them.'),null;void 0===a[c]&&(a[c]=[]),a[c].push(m.attributes[c]),g++}if(g!==o.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+l+". Make sure all geometries have the same number of attributes."),null;if(u!==m.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+l+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(var c in m.morphAttributes){if(!i.has(c))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+l+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===n[c]&&(n[c]=[]),n[c].push(m.morphAttributes[c])}if(s.userData.mergedUserData=s.userData.mergedUserData||[],s.userData.mergedUserData.push(m.userData),r){var d;if(t)d=m.index.count;else{if(void 0===m.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+l+". The geometry must have either an index or a position attribute"),null;d=m.attributes.position.count}s.addGroup(f,d,l),f+=d}}if(t){var h=0,b=[];for(l=0;l<e.length;++l){for(var v=e[l].index,y=0;y<v.count;++y)b.push(v.getX(y)+h);h+=e[l].attributes.position.count}s.setIndex(b)}for(var c in a){var p=this.mergeBufferAttributes(a[c]);if(!p)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+c+" attribute."),null;s.setAttribute(c,p)}for(var c in n){var B=n[c][0].length;if(0===B)break;s.morphAttributes=s.morphAttributes||{},s.morphAttributes[c]=[];for(l=0;l<B;++l){var A=[];for(y=0;y<n[c].length;++y)A.push(n[c][y][l]);var w=this.mergeBufferAttributes(A);if(!w)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+c+" morphAttribute."),null;s.morphAttributes[c].push(w)}}return s},mergeBufferAttributes:function(e){for(var r,t,o,i=0,a=0;a<e.length;++a){var n=e[a];if(n.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===r&&(r=n.array.constructor),r!==n.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===t&&(t=n.itemSize),t!==n.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===o&&(o=n.normalized),o!==n.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;i+=n.array.length}var u=new r(i),s=0;for(a=0;a<e.length;++a)u.set(e[a].array,s),s+=e[a].array.length;return new BufferAttribute(u,t,o)},interleaveAttributes:function(e){for(var r,t=0,o=0,i=0,a=e.length;i<a;++i){var n=e[i];if(void 0===r&&(r=n.array.constructor),r!==n.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;t+=n.array.length,o+=n.itemSize}var u=new InterleavedBuffer(new r(t),o),s=0,f=[],l=["getX","getY","getZ","getW"],m=["setX","setY","setZ","setW"],g=0;for(a=e.length;g<a;g++){var c=(n=e[g]).itemSize,d=n.count,h=new InterleavedBufferAttribute(u,c,s,n.normalized);f.push(h),s+=c;for(var b=0;b<d;b++)for(var v=0;v<c;v++)h[m[v]](b,n[l[v]](b))}return f},estimateBytesUsed:function(e){var r=0;for(var t in e.attributes){var o=e.getAttribute(t);r+=o.count*o.itemSize*o.array.BYTES_PER_ELEMENT}var i=e.getIndex();return r+=i?i.count*i.itemSize*i.array.BYTES_PER_ELEMENT:0},mergeVertices:function(e,r=1e-4){r=Math.max(r,Number.EPSILON);for(var t={},o=e.getIndex(),i=e.getAttribute("position"),a=o?o.count:i.count,n=0,u=Object.keys(e.attributes),s={},f={},l=[],m=["getX","getY","getZ","getW"],g=0,c=u.length;g<c;g++){s[p=u[g]]=[],(E=e.morphAttributes[p])&&(f[p]=new Array(E.length).fill().map(()=>[]))}var d=Math.log10(1/r),h=Math.pow(10,d);for(g=0;g<a;g++){var b=o?o.getX(g):g,v="",y=0;for(c=u.length;y<c;y++)for(var p=u[y],B=(w=e.getAttribute(p)).itemSize,A=0;A<B;A++)v+=`${~~(w[m[A]](b)*h)},`;if(v in t)l.push(t[v]);else{for(y=0,c=u.length;y<c;y++){p=u[y];var w=e.getAttribute(p),E=e.morphAttributes[p],T=(B=w.itemSize,s[p]),G=f[p];for(A=0;A<B;A++){var x=m[A];if(T.push(w[x](b)),E)for(var U=0,S=E.length;U<S;U++)G[U].push(E[U][x](b))}}t[v]=n,l.push(n),n++}}const R=e.clone();for(g=0,c=u.length;g<c;g++){p=u[g];var z=e.getAttribute(p),V=new z.array.constructor(s[p]);w=new BufferAttribute(V,z.itemSize,z.normalized);if(R.setAttribute(p,w),p in f)for(y=0;y<f[p].length;y++){var D=e.morphAttributes[p][y],M=(V=new D.array.constructor(f[p][y]),new BufferAttribute(V,D.itemSize,D.normalized));R.morphAttributes[p][y]=M}}return R.setIndex(l),R},toTrianglesDrawMode:function(e,r){if(r===TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(r===TriangleFanDrawMode||r===TriangleStripDrawMode){var t=e.getIndex();if(null===t){var o=[],i=e.getAttribute("position");if(void 0===i)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(var a=0;a<i.count;a++)o.push(a);e.setIndex(o),t=e.getIndex()}var n=t.count-2,u=[];if(r===TriangleFanDrawMode)for(a=1;a<=n;a++)u.push(t.getX(0)),u.push(t.getX(a)),u.push(t.getX(a+1));else for(a=0;a<n;a++)a%2==0?(u.push(t.getX(a)),u.push(t.getX(a+1)),u.push(t.getX(a+2))):(u.push(t.getX(a+2)),u.push(t.getX(a+1)),u.push(t.getX(a)));u.length/3!==n&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");var s=e.clone();return s.setIndex(u),s.clearGroups(),s}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",r),e}};export{BufferGeometryUtils};
//# sourceMappingURL=/sm/e1b058ce35d5a71452b9b4d33a77ff65acd315a627a706868c7bc114e046e052.map