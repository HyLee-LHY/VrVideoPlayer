/**
 * Minified by jsDelivr using Terser v3.14.1.
 * Original file: /npm/three@0.117.1/examples/jsm/nodes/misc/TextureCubeUVNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{TempNode}from"../core/TempNode.js";import{ConstNode}from"../core/ConstNode.js";import{StructNode}from"../core/StructNode.js";import{FunctionNode}from"../core/FunctionNode.js";import{FunctionCallNode}from"../core/FunctionCallNode.js";import{ExpressionNode}from"../core/ExpressionNode.js";import{FloatNode}from"../inputs/FloatNode.js";import{OperatorNode}from"../math/OperatorNode.js";import{MathNode}from"../math/MathNode.js";import{ColorSpaceNode}from"../utils/ColorSpaceNode.js";function TextureCubeUVNode(t,e,o){TempNode.call(this,"v4"),this.value=t,this.uv=e,this.bias=o}TextureCubeUVNode.Nodes=function(){var t=new StructNode("struct TextureCubeUVData {\n\t\t\tvec4 tl;\n\t\t\tvec4 tr;\n\t\t\tvec4 br;\n\t\t\tvec4 bl;\n\t\t\tvec2 f;\n\t\t}"),e=new ConstNode("float cubeUV_maxMipLevel 8.0",!0),o=new ConstNode("float cubeUV_minMipLevel 4.0",!0),n=new ConstNode("float cubeUV_maxTileSize 256.0",!0),i=new ConstNode("float cubeUV_minTileSize 16.0",!0),r=new FunctionNode("float getFace(vec3 direction) {\n\t\t\t\tvec3 absDirection = abs(direction);\n\t\t\t\tfloat face = -1.0;\n\t\t\t\tif (absDirection.x > absDirection.z) {\n\t\t\t\t\tif (absDirection.x > absDirection.y)\n\t\t\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\t\t\telse\n\t\t\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t\t\t} else {\n\t\t\t\t\tif (absDirection.z > absDirection.y)\n\t\t\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\t\t\telse\n\t\t\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t\t\t}\n\t\t\t\treturn face;\n\t\t}");r.useKeywords=!1;var c=new FunctionNode("vec2 getUV(vec3 direction, float face) {\n\t\t\t\tvec2 uv;\n\t\t\t\tif (face == 0.0) {\n\t\t\t\t\tuv = vec2(direction.z, direction.y) / abs(direction.x); // pos x\n\t\t\t\t} else if (face == 1.0) {\n\t\t\t\t\tuv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y\n\t\t\t\t} else if (face == 2.0) {\n\t\t\t\t\tuv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z\n\t\t\t\t} else if (face == 3.0) {\n\t\t\t\t\tuv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x\n\t\t\t\t} else if (face == 4.0) {\n\t\t\t\t\tuv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y\n\t\t\t\t} else {\n\t\t\t\t\tuv = vec2(direction.x, direction.y) / abs(direction.z); // neg z\n\t\t\t\t}\n\t\t\t\treturn 0.5 * (uv + 1.0);\n\t\t}");c.useKeywords=!1;var a=new FunctionNode("TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n\n\t\t\tfloat face = getFace(direction);\n\t\t\tfloat filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n\t\t\tmipInt = max(mipInt, cubeUV_minMipLevel);\n\t\t\tfloat faceSize = exp2(mipInt);\n\n\t\t\tfloat texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n\n\t\t\tvec2 uv = getUV(direction, face) * (faceSize - 1.0);\n\t\t\tvec2 f = fract(uv);\n\t\t\tuv += 0.5 - f;\n\t\t\tif (face > 2.0) {\n\t\t\t\tuv.y += faceSize;\n\t\t\t\tface -= 3.0;\n\t\t\t}\n\t\t\tuv.x += face * faceSize;\n\t\t\tif(mipInt < cubeUV_maxMipLevel){\n\t\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t\t}\n\t\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\t\tuv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n\t\t\tuv *= texelSize;\n\n\t\t\tvec4 tl = texture2D(envMap, uv);\n\t\t\tuv.x += texelSize;\n\t\t\tvec4 tr = texture2D(envMap, uv);\n\t\t\tuv.y += texelSize;\n\t\t\tvec4 br = texture2D(envMap, uv);\n\t\t\tuv.x -= texelSize;\n\t\t\tvec4 bl = texture2D(envMap, uv);\n\n\t\t\treturn TextureCubeUVData( tl, tr, br, bl, f );\n\t\t}",[t,r,c,e,o,n,i]);a.useKeywords=!1;var s=new ConstNode("float r0 1.0",!0),u=new ConstNode("float v0 0.339",!0),d=new ConstNode("float m0 -2.0",!0),l=new ConstNode("float r1 0.8",!0),p=new ConstNode("float v1 0.276",!0),v=new ConstNode("float m1 -1.0",!0),N=new ConstNode("float r4 0.4",!0),f=new ConstNode("float v4 0.046",!0),b=new ConstNode("float m4 2.0",!0),m=new ConstNode("float r5 0.305",!0),x=new ConstNode("float v5 0.016",!0),h=new ConstNode("float m5 3.0",!0),C=new ConstNode("float r6 0.21",!0),S=new ConstNode("float v6 0.0038",!0),T=new ConstNode("float m6 4.0",!0);return{bilinearCubeUV:a,roughnessToMip:new FunctionNode("float roughnessToMip(float roughness) {\n\t\t\tfloat mip = 0.0;\n\t\t\tif (roughness >= r1) {\n\t\t\t\tmip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n\t\t\t} else if (roughness >= r4) {\n\t\t\t\tmip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n\t\t\t} else if (roughness >= r5) {\n\t\t\t\tmip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n\t\t\t} else if (roughness >= r6) {\n\t\t\t\tmip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n\t\t\t} else {\n\t\t\t\tmip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25\n\t\t\t}\n\t\t\treturn mip;\n\t\t}",[s,u,d,l,p,v,N,f,b,m,x,h,C,S,T]),m0:d,cubeUV_maxMipLevel:e}}(),TextureCubeUVNode.prototype=Object.create(TempNode.prototype),TextureCubeUVNode.prototype.constructor=TextureCubeUVNode,TextureCubeUVNode.prototype.nodeType="TextureCubeUV",TextureCubeUVNode.prototype.bilinearCubeUV=function(t,e,o,n){var i=new FunctionCallNode(TextureCubeUVNode.Nodes.bilinearCubeUV,[e,o,n]);this.colorSpaceTL=this.colorSpaceTL||new ColorSpaceNode(new ExpressionNode("","v4")),this.colorSpaceTL.fromDecoding(t.getTextureEncodingFromMap(this.value.value)),this.colorSpaceTL.input.parse(i.build(t)+".tl"),this.colorSpaceTR=this.colorSpaceTR||new ColorSpaceNode(new ExpressionNode("","v4")),this.colorSpaceTR.fromDecoding(t.getTextureEncodingFromMap(this.value.value)),this.colorSpaceTR.input.parse(i.build(t)+".tr"),this.colorSpaceBL=this.colorSpaceBL||new ColorSpaceNode(new ExpressionNode("","v4")),this.colorSpaceBL.fromDecoding(t.getTextureEncodingFromMap(this.value.value)),this.colorSpaceBL.input.parse(i.build(t)+".bl"),this.colorSpaceBR=this.colorSpaceBR||new ColorSpaceNode(new ExpressionNode("","v4")),this.colorSpaceBR.fromDecoding(t.getTextureEncodingFromMap(this.value.value)),this.colorSpaceBR.input.parse(i.build(t)+".br");var r={include:t.isShader("vertex"),ignoreCache:!0};t.addContext(r),this.colorSpaceTLExp=new ExpressionNode(this.colorSpaceTL.build(t,"v4"),"v4"),this.colorSpaceTRExp=new ExpressionNode(this.colorSpaceTR.build(t,"v4"),"v4"),this.colorSpaceBLExp=new ExpressionNode(this.colorSpaceBL.build(t,"v4"),"v4"),this.colorSpaceBRExp=new ExpressionNode(this.colorSpaceBR.build(t,"v4"),"v4"),t.removeContext();var c=new ExpressionNode("mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )","v4");return c.keywords.cubeUV_TL=this.colorSpaceTLExp,c.keywords.cubeUV_TR=this.colorSpaceTRExp,c.keywords.cubeUV_BL=this.colorSpaceBLExp,c.keywords.cubeUV_BR=this.colorSpaceBRExp,c.keywords.cubeUV=i,c},TextureCubeUVNode.prototype.generate=function(t,e){if(t.isShader("fragment")){var o=this.uv,n=this.bias||t.context.roughness,i=new FunctionCallNode(TextureCubeUVNode.Nodes.roughnessToMip,[n]),r=new MathNode(i,TextureCubeUVNode.Nodes.m0,TextureCubeUVNode.Nodes.cubeUV_maxMipLevel,MathNode.CLAMP),c=new MathNode(r,MathNode.FLOOR),a=new MathNode(r,MathNode.FRACT),s=this.bilinearCubeUV(t,this.value,o,c),u=this.bilinearCubeUV(t,this.value,o,new OperatorNode(c,new FloatNode(1).setReadonly(!0),OperatorNode.ADD)),d=new MathNode(s,u,a,MathNode.MIX);return t.format(d.build(t),"v4",e)}return console.warn("THREE.TextureCubeUVNode is not compatible with "+t.shader+" shader."),t.format("vec4( 0.0 )",this.getType(t),e)},TextureCubeUVNode.prototype.toJSON=function(t){var e=this.getJSONNode(t);return e||((e=this.createJSONNode(t)).value=this.value.toJSON(t).uuid,e.uv=this.uv.toJSON(t).uuid,e.bias=this.bias.toJSON(t).uuid),e};export{TextureCubeUVNode};
//# sourceMappingURL=/sm/a4f3682e9f7713093ece93b08cf4155a9d662604f36b2ae66703b291c6cfccac.map