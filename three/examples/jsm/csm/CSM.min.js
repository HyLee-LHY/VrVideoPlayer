/**
 * Minified by jsDelivr using Terser v3.14.1.
 * Original file: /npm/three@0.117.1/examples/jsm/csm/CSM.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{Vector2,Vector3,DirectionalLight,MathUtils,ShaderChunk,Matrix4,Box3}from"../../../build/three.module.js";import Frustum from"./Frustum.js";import Shader from"./Shader.js";const _cameraToLightMatrix=new Matrix4,_lightSpaceFrustum=new Frustum,_center=new Vector3,_bbox=new Box3,_uniformArray=[],_logArray=[];export class CSM{constructor(t){t=t||{},this.camera=t.camera,this.parent=t.parent,this.cascades=t.cascades||3,this.maxFar=t.maxFar||1e5,this.mode=t.mode||"practical",this.shadowMapSize=t.shadowMapSize||2048,this.shadowBias=t.shadowBias||1e-6,this.lightDirection=t.lightDirection||new Vector3(1,-1,1).normalize(),this.lightIntensity=t.lightIntensity||1,this.lightNear=t.lightNear||1,this.lightFar=t.lightFar||2e3,this.lightMargin=t.lightMargin||200,this.customSplitsCallback=t.customSplitsCallback,this.fade=!1,this.mainFrustum=new Frustum,this.frustums=[],this.breaks=[],this.lights=[],this.shaders=new Map,this.createLights(),this.updateFrustums(),this.injectInclude()}createLights(){for(let t=0;t<this.cascades;t++){const t=new DirectionalLight(16777215,this.lightIntensity);t.castShadow=!0,t.shadow.mapSize.width=this.shadowMapSize,t.shadow.mapSize.height=this.shadowMapSize,t.shadow.camera.near=this.lightNear,t.shadow.camera.far=this.lightFar,t.shadow.bias=this.shadowBias,this.parent.add(t),this.parent.add(t.target),this.lights.push(t)}}initCascades(){const t=this.camera;t.updateProjectionMatrix(),this.mainFrustum.setFromProjectionMatrix(t.projectionMatrix,this.maxFar),this.mainFrustum.split(this.breaks,this.frustums)}updateShadowBounds(){const t=this.frustums;for(let e=0;e<t.length;e++){const t=this.lights[e].shadow.camera,a=this.frustums[e],s=a.vertices.near,i=a.vertices.far,r=i[0];let h;h=r.distanceTo(i[2])>r.distanceTo(s[2])?i[2]:s[2];let o=r.distanceTo(h);if(this.fade){const t=this.camera,e=Math.max(t.far,this.maxFar),s=a.vertices.far[0].z/(e-t.near);o+=.25*Math.pow(s,2)*(e-t.near)}t.left=-o/2,t.right=o/2,t.top=o/2,t.bottom=-o/2,t.updateProjectionMatrix()}}getBreaks(){const t=this.camera,e=Math.min(t.far,this.maxFar);switch(this.breaks.length=0,this.mode){case"uniform":a(this.cascades,t.near,e,this.breaks);break;case"logarithmic":s(this.cascades,t.near,e,this.breaks);break;case"practical":!function(t,e,i,r,h){_uniformArray.length=0,_logArray.length=0,s(t,e,i,_logArray),a(t,e,i,_uniformArray);for(let e=1;e<t;e++)h.push(MathUtils.lerp(_uniformArray[e-1],_logArray[e-1],r));h.push(1)}(this.cascades,t.near,e,.5,this.breaks);break;case"custom":void 0===this.customSplitsCallback&&console.error("CSM: Custom split scheme callback not defined."),this.customSplitsCallback(this.cascades,t.near,e,this.breaks)}function a(t,e,a,s){for(let i=1;i<t;i++)s.push((e+(a-e)*i/t)/a);s.push(1)}function s(t,e,a,s){for(let i=1;i<t;i++)s.push(e*(a/e)**(i/t)/a);s.push(1)}}update(){const t=this.camera,e=this.frustums;for(let a=0;a<e.length;a++){const s=this.lights[a],i=s.shadow.camera,r=(i.right-i.left)/this.shadowMapSize,h=(i.top-i.bottom)/this.shadowMapSize;s.shadow.camera.updateMatrixWorld(!0),_cameraToLightMatrix.multiplyMatrices(s.shadow.camera.matrixWorldInverse,t.matrixWorld),e[a].toSpace(_cameraToLightMatrix,_lightSpaceFrustum);const o=_lightSpaceFrustum.vertices.near,n=_lightSpaceFrustum.vertices.far;_bbox.makeEmpty();for(let t=0;t<4;t++)_bbox.expandByPoint(o[t]),_bbox.expandByPoint(n[t]);_bbox.getCenter(_center),_center.z=_bbox.max.z+this.lightMargin,_center.x=Math.floor(_center.x/r)*r,_center.y=Math.floor(_center.y/h)*h,_center.applyMatrix4(s.shadow.camera.matrixWorld),s.position.copy(_center),s.target.position.copy(_center),s.target.position.x+=this.lightDirection.x,s.target.position.y+=this.lightDirection.y,s.target.position.z+=this.lightDirection.z}}injectInclude(){ShaderChunk.lights_fragment_begin=Shader.lights_fragment_begin,ShaderChunk.lights_pars_begin=Shader.lights_pars_begin}setupMaterial(t){t.defines=t.defines||{},t.defines.USE_CSM=1,t.defines.CSM_CASCADES=this.cascades,this.fade&&(t.defines.CSM_FADE="");const e=[],a=this,s=this.shaders;t.onBeforeCompile=function(i){const r=Math.min(a.camera.far,a.maxFar);a.getExtendedBreaks(e),i.uniforms.CSM_cascades={value:e},i.uniforms.cameraNear={value:a.camera.near},i.uniforms.shadowFar={value:r},s.set(t,i)},s.set(t,null)}updateUniforms(){const t=Math.min(this.camera.far,this.maxFar);this.shaders.forEach(function(e,a){if(null!==e){const a=e.uniforms;this.getExtendedBreaks(a.CSM_cascades.value),a.cameraNear.value=this.camera.near,a.shadowFar.value=t}!this.fade&&"CSM_FADE"in a.defines?(delete a.defines.CSM_FADE,a.needsUpdate=!0):!this.fade||"CSM_FADE"in a.defines||(a.defines.CSM_FADE="",a.needsUpdate=!0)},this)}getExtendedBreaks(t){for(;t.length<this.breaks.length;)t.push(new Vector2);t.length=this.breaks.length;for(let e=0;e<this.cascades;e++){let a=this.breaks[e],s=this.breaks[e-1]||0;t[e].x=s,t[e].y=a}}updateFrustums(){this.getBreaks(),this.initCascades(),this.updateShadowBounds(),this.updateUniforms()}remove(){for(let t=0;t<this.lights.length;t++)this.parent.remove(this.lights[t])}dispose(){const t=this.shaders;t.forEach(function(t,e){delete e.onBeforeCompile,delete e.defines.USE_CSM,delete e.defines.CSM_CASCADES,delete e.defines.CSM_FADE,null!==t&&(delete t.uniforms.CSM_cascades,delete t.uniforms.cameraNear,delete t.uniforms.shadowFar),e.needsUpdate=!0}),t.clear()}}
//# sourceMappingURL=/sm/3eede98811ac57c36c665b05036a36f2f703d05ddcce357878b90f93b69bd133.map