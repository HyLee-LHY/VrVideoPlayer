/**
 * Minified by jsDelivr using Terser v3.14.1.
 * Original file: /npm/three@0.117.1/examples/jsm/loaders/obj2/shared/MeshReceiver.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{BufferAttribute,BufferGeometry,LineSegments,Mesh,Points}from"../../../../../build/three.module.js";const MeshReceiver=function(e){this.logging={enabled:!1,debug:!1},this.callbacks={onProgress:null,onMeshAlter:null},this.materialHandler=e};MeshReceiver.prototype={constructor:MeshReceiver,setLogging:function(e,t){this.logging.enabled=!0===e,this.logging.debug=!0===t},_setCallbacks:function(e,t){null!=e&&e instanceof Function&&(this.callbacks.onProgress=e),null!=t&&t instanceof Function&&(this.callbacks.onMeshAlter=t)},buildMeshes:function(e){let t,s,r,i=e.params.meshName,n=e.buffers,l=new BufferGeometry;void 0!==n.vertices&&null!==n.vertices&&l.setAttribute("position",new BufferAttribute(new Float32Array(n.vertices),3)),void 0!==n.indices&&null!==n.indices&&l.setIndex(new BufferAttribute(new Uint32Array(n.indices),1)),void 0!==n.colors&&null!==n.colors&&l.setAttribute("color",new BufferAttribute(new Float32Array(n.colors),3)),void 0!==n.normals&&null!==n.normals?l.setAttribute("normal",new BufferAttribute(new Float32Array(n.normals),3)):l.computeVertexNormals(),void 0!==n.uvs&&null!==n.uvs&&l.setAttribute("uv",new BufferAttribute(new Float32Array(n.uvs),2)),void 0!==n.skinIndex&&null!==n.skinIndex&&l.setAttribute("skinIndex",new BufferAttribute(new Uint16Array(n.skinIndex),4)),void 0!==n.skinWeight&&null!==n.skinWeight&&l.setAttribute("skinWeight",new BufferAttribute(new Float32Array(n.skinWeight),4));let o=e.materials.materialNames,a=e.materials.multiMaterial,u=[];for(r in o)s=o[r],t=this.materialHandler.getMaterial(s),a&&u.push(t);if(a){t=u;let s,i=e.materials.materialGroups;for(r in i)s=i[r],l.addGroup(s.start,s.count,s.index)}let h,d,c=[],m=!0,f=null===e.geometryType?0:e.geometryType;if(this.callbacks.onMeshAlter&&(d=this.callbacks.onMeshAlter({detail:{meshName:i,bufferGeometry:l,material:t,geometryType:f}})),d)if(d.isDisregardMesh())m=!1;else if(d.providesAlteredMeshes()){for(let e in d.meshes)c.push(d.meshes[e]);m=!1}m&&(e.computeBoundingSphere&&l.computeBoundingSphere(),(h=0===f?new Mesh(l,t):1===f?new LineSegments(l,t):new Points(l,t)).name=i,c.push(h));let g=e.params.meshName;if(c.length>0){let t=[];for(let e in c)h=c[e],t[e]=h.name;g+=": Adding mesh(es) ("+t.length+": "+t+") from input mesh: "+i,g+=" ("+(100*e.progress.numericalValue).toFixed(2)+"%)"}else g+=": Not adding mesh: "+i,g+=" ("+(100*e.progress.numericalValue).toFixed(2)+"%)";return this.callbacks.onProgress&&this.callbacks.onProgress("progress",g,e.progress.numericalValue),c}};const LoadedMeshUserOverride=function(e,t){this.disregardMesh=!0===e,this.alteredMesh=!0===t,this.meshes=[]};LoadedMeshUserOverride.prototype={constructor:LoadedMeshUserOverride,addMesh:function(e){this.meshes.push(e),this.alteredMesh=!0},isDisregardMesh:function(){return this.disregardMesh},providesAlteredMeshes:function(){return this.alteredMesh}};export{MeshReceiver,LoadedMeshUserOverride};
//# sourceMappingURL=/sm/60af2fe6acfbeec1b82a6bb098b1f7c3b0f7aafb2ad1b4f94c7ec12c00f9a126.map