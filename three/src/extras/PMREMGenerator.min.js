/**
 * Minified by jsDelivr using Terser v3.14.1.
 * Original file: /npm/three@0.117.1/src/extras/PMREMGenerator.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{CubeUVReflectionMapping,GammaEncoding,LinearEncoding,LinearToneMapping,NearestFilter,NoBlending,RGBDEncoding,RGBEEncoding,RGBEFormat,RGBM16Encoding,RGBM7Encoding,UnsignedByteType,sRGBEncoding}from"../constants.js";import{BufferAttribute}from"../core/BufferAttribute.js";import{BufferGeometry}from"../core/BufferGeometry.js";import{Mesh}from"../objects/Mesh.js";import{OrthographicCamera}from"../cameras/OrthographicCamera.js";import{PerspectiveCamera}from"../cameras/PerspectiveCamera.js";import{RawShaderMaterial}from"../materials/RawShaderMaterial.js";import{Vector2}from"../math/Vector2.js";import{Vector3}from"../math/Vector3.js";import{WebGLRenderTarget}from"../renderers/WebGLRenderTarget.js";var LOD_MIN=4,LOD_MAX=8,SIZE_MAX=Math.pow(2,LOD_MAX),EXTRA_LOD_SIGMA=[.125,.215,.35,.446,.526,.582],TOTAL_LODS=LOD_MAX-LOD_MIN+1+EXTRA_LOD_SIGMA.length,MAX_SAMPLES=20,ENCODINGS={[LinearEncoding]:0,[sRGBEncoding]:1,[RGBEEncoding]:2,[RGBM7Encoding]:3,[RGBM16Encoding]:4,[RGBDEncoding]:5,[GammaEncoding]:6},_flatCamera=new OrthographicCamera,{_lodPlanes:_lodPlanes,_sizeLods:_sizeLods,_sigmas:_sigmas}=_createPlanes(),_oldTarget=null,PHI=(1+Math.sqrt(5))/2,INV_PHI=1/PHI,_axisDirections=[new Vector3(1,1,1),new Vector3(-1,1,1),new Vector3(1,1,-1),new Vector3(-1,1,-1),new Vector3(0,PHI,INV_PHI),new Vector3(0,PHI,-INV_PHI),new Vector3(INV_PHI,0,PHI),new Vector3(-INV_PHI,0,PHI),new Vector3(PHI,INV_PHI,0),new Vector3(-PHI,INV_PHI,0)];function PMREMGenerator(e){this._renderer=e,this._pingPongRenderTarget=null,this._blurMaterial=_getBlurShader(MAX_SAMPLES),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}function _isLDR(e){return void 0!==e&&e.type===UnsignedByteType&&(e.encoding===LinearEncoding||e.encoding===sRGBEncoding||e.encoding===GammaEncoding)}function _createPlanes(){for(var e=[],t=[],n=[],r=LOD_MAX,i=0;i<TOTAL_LODS;i++){var a=Math.pow(2,r);t.push(a);var o=1/a;i>LOD_MAX-LOD_MIN?o=EXTRA_LOD_SIGMA[i-LOD_MAX+LOD_MIN-1]:0==i&&(o=0),n.push(o);for(var u=1/(a-1),l=-u/2,s=1+u/2,c=[l,l,s,l,s,s,l,l,s,s,l,s],d=new Float32Array(108),p=new Float32Array(72),g=new Float32Array(36),v=0;v<6;v++){var _=v%3*2/3-1,m=v>2?0:-1,h=[_,m,0,_+2/3,m,0,_+2/3,m+1,0,_,m,0,_+2/3,m+1,0,_,m+1,0];d.set(h,18*v),p.set(c,12*v);var f=[v,v,v,v,v,v];g.set(f,6*v)}var M=new BufferGeometry;M.setAttribute("position",new BufferAttribute(d,3)),M.setAttribute("uv",new BufferAttribute(p,2)),M.setAttribute("faceIndex",new BufferAttribute(g,1)),e.push(M),r>LOD_MIN&&r--}return{_lodPlanes:e,_sizeLods:t,_sigmas:n}}function _createRenderTarget(e){var t=new WebGLRenderTarget(3*SIZE_MAX,3*SIZE_MAX,e);return t.texture.mapping=CubeUVReflectionMapping,t.texture.name="PMREM.cubeUv",t.scissorTest=!0,t}function _setViewport(e,t,n,r,i){e.viewport.set(t,n,r,i),e.scissor.set(t,n,r,i)}function _getBlurShader(e){var t=new Float32Array(e),n=new Vector3(0,1,0),r=new RawShaderMaterial({defines:{n:e},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:t},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:n},inputEncoding:{value:ENCODINGS[LinearEncoding]},outputEncoding:{value:ENCODINGS[LinearEncoding]}},vertexShader:_getCommonVertexShader(),fragmentShader:`\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n${_getEncodings()}\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvec3 getSample(float theta, vec3 axis) {\n\tfloat cosTheta = cos(theta);\n\t// Rodrigues' axis-angle rotation\n\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t+ cross(axis, vOutputDirection) * sin(theta)\n\t\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\treturn bilinearCubeUV(envMap, sampleDirection, mipInt);\n}\n\nvoid main() {\n\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\tif (all(equal(axis, vec3(0.0))))\n\t\taxis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);\n\taxis = normalize(axis);\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb += weights[0] * getSample(0.0, axis);\n\tfor (int i = 1; i < n; i++) {\n\t\tif (i >= samples)\n\t\t\tbreak;\n\t\tfloat theta = dTheta * float(i);\n\t\tgl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\n\t\tgl_FragColor.rgb += weights[i] * getSample(theta, axis);\n\t}\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,blending:NoBlending,depthTest:!1,depthWrite:!1});return r.type="SphericalGaussianBlur",r}function _getEquirectShader(){var e=new Vector2(1,1),t=new RawShaderMaterial({uniforms:{envMap:{value:null},texelSize:{value:e},inputEncoding:{value:ENCODINGS[LinearEncoding]},outputEncoding:{value:ENCODINGS[LinearEncoding]}},vertexShader:_getCommonVertexShader(),fragmentShader:`\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n${_getEncodings()}\n\n#include <common>\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tvec3 outputDirection = normalize(vOutputDirection);\n\tvec2 uv = equirectUv( outputDirection );\n\tvec2 f = fract(uv / texelSize - 0.5);\n\tuv -= f * texelSize;\n\tvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x += texelSize.x;\n\tvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.y += texelSize.y;\n\tvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x -= texelSize.x;\n\tvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tvec3 tm = mix(tl, tr, f.x);\n\tvec3 bm = mix(bl, br, f.x);\n\tgl_FragColor.rgb = mix(tm, bm, f.y);\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,blending:NoBlending,depthTest:!1,depthWrite:!1});return t.type="EquirectangularToCubeUV",t}function _getCubemapShader(){var e=new RawShaderMaterial({uniforms:{envMap:{value:null},inputEncoding:{value:ENCODINGS[LinearEncoding]},outputEncoding:{value:ENCODINGS[LinearEncoding]}},vertexShader:_getCommonVertexShader(),fragmentShader:`\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\n\n${_getEncodings()}\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,blending:NoBlending,depthTest:!1,depthWrite:!1});return e.type="CubemapToCubeUV",e}function _getCommonVertexShader(){return"\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\n\n// RH coordinate system; PMREM face-indexing convention\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\t} else if (face == 2.0) {\n\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\t} else if (face == 5.0) {\n\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\t}\n\treturn direction;\n}\n\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t"}function _getEncodings(){return"\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t"}PMREMGenerator.prototype={constructor:PMREMGenerator,fromScene:function(e,t=0,n=.1,r=100){_oldTarget=this._renderer.getRenderTarget();var i=this._allocateTargets();return this._sceneToCubeUV(e,n,r,i),t>0&&this._blur(i,0,0,t),this._applyPMREM(i),this._cleanup(i),i},fromEquirectangular:function(e){return e.magFilter=NearestFilter,e.minFilter=NearestFilter,e.generateMipmaps=!1,this.fromCubemap(e)},fromCubemap:function(e){_oldTarget=this._renderer.getRenderTarget();var t=this._allocateTargets(e);return this._textureToCubeUV(e,t),this._applyPMREM(t),this._cleanup(t),t},compileCubemapShader:function(){null===this._cubemapShader&&(this._cubemapShader=_getCubemapShader(),this._compileMaterial(this._cubemapShader))},compileEquirectangularShader:function(){null===this._equirectShader&&(this._equirectShader=_getEquirectShader(),this._compileMaterial(this._equirectShader))},dispose:function(){this._blurMaterial.dispose(),null!==this._cubemapShader&&this._cubemapShader.dispose(),null!==this._equirectShader&&this._equirectShader.dispose();for(var e=0;e<_lodPlanes.length;e++)_lodPlanes[e].dispose()},_cleanup:function(e){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(_oldTarget),e.scissorTest=!1,e.setSize(e.width,e.height)},_allocateTargets:function(e){var t={magFilter:NearestFilter,minFilter:NearestFilter,generateMipmaps:!1,type:UnsignedByteType,format:RGBEFormat,encoding:_isLDR(e)?e.encoding:RGBEEncoding,depthBuffer:!1,stencilBuffer:!1},n=_createRenderTarget(t);return n.depthBuffer=!e,this._pingPongRenderTarget=_createRenderTarget(t),n},_compileMaterial:function(e){var t=new Mesh(_lodPlanes[0],e);this._renderer.compile(t,_flatCamera)},_sceneToCubeUV:function(e,t,n,r){var i=new PerspectiveCamera(90,1,t,n),a=[1,-1,1,1,1,1],o=[1,1,1,-1,-1,-1],u=this._renderer,l=u.outputEncoding,s=u.toneMapping,c=u.toneMappingExposure,d=u.getClearColor(),p=u.getClearAlpha();u.toneMapping=LinearToneMapping,u.toneMappingExposure=1,u.outputEncoding=LinearEncoding;var g=e.background;if(g&&g.isColor){g.convertSRGBToLinear();var v=Math.max(g.r,g.g,g.b),_=Math.min(Math.max(Math.ceil(Math.log2(v)),-128),127);g=g.multiplyScalar(Math.pow(2,-_));var m=(_+128)/255;u.setClearColor(g,m),e.background=null}for(var h=0;h<6;h++){var f=h%3;0==f?(i.up.set(0,a[h],0),i.lookAt(o[h],0,0)):1==f?(i.up.set(0,0,a[h]),i.lookAt(0,o[h],0)):(i.up.set(0,a[h],0),i.lookAt(0,0,o[h])),_setViewport(r,f*SIZE_MAX,h>2?SIZE_MAX:0,SIZE_MAX,SIZE_MAX),u.setRenderTarget(r),u.render(e,i)}u.toneMapping=s,u.toneMappingExposure=c,u.outputEncoding=l,u.setClearColor(d,p)},_textureToCubeUV:function(e,t){var n=this._renderer;e.isCubeTexture?null==this._cubemapShader&&(this._cubemapShader=_getCubemapShader()):null==this._equirectShader&&(this._equirectShader=_getEquirectShader());var r=e.isCubeTexture?this._cubemapShader:this._equirectShader,i=new Mesh(_lodPlanes[0],r),a=r.uniforms;a.envMap.value=e,e.isCubeTexture||a.texelSize.value.set(1/e.image.width,1/e.image.height),a.inputEncoding.value=ENCODINGS[e.encoding],a.outputEncoding.value=ENCODINGS[t.texture.encoding],_setViewport(t,0,0,3*SIZE_MAX,2*SIZE_MAX),n.setRenderTarget(t),n.render(i,_flatCamera)},_applyPMREM:function(e){var t=this._renderer,n=t.autoClear;t.autoClear=!1;for(var r=1;r<TOTAL_LODS;r++){var i=Math.sqrt(_sigmas[r]*_sigmas[r]-_sigmas[r-1]*_sigmas[r-1]),a=_axisDirections[(r-1)%_axisDirections.length];this._blur(e,r-1,r,i,a)}t.autoClear=n},_blur:function(e,t,n,r,i){var a=this._pingPongRenderTarget;this._halfBlur(e,a,t,n,r,"latitudinal",i),this._halfBlur(a,e,n,n,r,"longitudinal",i)},_halfBlur:function(e,t,n,r,i,a,o){var u=this._renderer,l=this._blurMaterial;"latitudinal"!==a&&"longitudinal"!==a&&console.error("blur direction must be either latitudinal or longitudinal!");var s=new Mesh(_lodPlanes[r],l),c=l.uniforms,d=_sizeLods[n]-1,p=isFinite(i)?Math.PI/(2*d):2*Math.PI/(2*MAX_SAMPLES-1),g=i/p,v=isFinite(i)?1+Math.floor(3*g):MAX_SAMPLES;v>MAX_SAMPLES&&console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${MAX_SAMPLES}`);for(var _=[],m=0,h=0;h<MAX_SAMPLES;++h){var f=h/g,M=Math.exp(-f*f/2);_.push(M),0==h?m+=M:h<v&&(m+=2*M)}for(h=0;h<_.length;h++)_[h]=_[h]/m;c.envMap.value=e.texture,c.samples.value=v,c.weights.value=_,c.latitudinal.value="latitudinal"===a,o&&(c.poleAxis.value=o),c.dTheta.value=p,c.mipInt.value=LOD_MAX-n,c.inputEncoding.value=ENCODINGS[e.texture.encoding],c.outputEncoding.value=ENCODINGS[e.texture.encoding];var E=_sizeLods[r];_setViewport(t,f=3*Math.max(0,SIZE_MAX-2*E),(0===r?0:2*SIZE_MAX)+2*E*(r>LOD_MAX-LOD_MIN?r-LOD_MAX+LOD_MIN:0),3*E,2*E),u.setRenderTarget(t),u.render(s,_flatCamera)}};export{PMREMGenerator};
//# sourceMappingURL=/sm/e94071a414fec78b201325c48d8bb8188b706781bbff0a2dd5d87eb601494866.map