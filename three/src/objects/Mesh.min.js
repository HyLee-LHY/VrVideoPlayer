/**
 * Minified by jsDelivr using Terser v3.14.1.
 * Original file: /npm/three@0.117.1/src/objects/Mesh.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{Vector3}from"../math/Vector3.js";import{Vector2}from"../math/Vector2.js";import{Sphere}from"../math/Sphere.js";import{Ray}from"../math/Ray.js";import{Matrix4}from"../math/Matrix4.js";import{Object3D}from"../core/Object3D.js";import{Triangle}from"../math/Triangle.js";import{Face3}from"../core/Face3.js";import{DoubleSide,BackSide}from"../constants.js";import{MeshBasicMaterial}from"../materials/MeshBasicMaterial.js";import{BufferGeometry}from"../core/BufferGeometry.js";var _inverseMatrix=new Matrix4,_ray=new Ray,_sphere=new Sphere,_vA=new Vector3,_vB=new Vector3,_vC=new Vector3,_tempA=new Vector3,_tempB=new Vector3,_tempC=new Vector3,_morphA=new Vector3,_morphB=new Vector3,_morphC=new Vector3,_uvA=new Vector2,_uvB=new Vector2,_uvC=new Vector2,_intersectionPoint=new Vector3,_intersectionPointWorld=new Vector3;function Mesh(e,t){Object3D.call(this),this.type="Mesh",this.geometry=void 0!==e?e:new BufferGeometry,this.material=void 0!==t?t:new MeshBasicMaterial,this.updateMorphTargets()}function checkIntersection(e,t,r,o,i,a,n,s){if(null===(t.side===BackSide?o.intersectTriangle(n,a,i,!0,s):o.intersectTriangle(i,a,n,t.side!==DoubleSide,s)))return null;_intersectionPointWorld.copy(s),_intersectionPointWorld.applyMatrix4(e.matrixWorld);var c=r.ray.origin.distanceTo(_intersectionPointWorld);return c<r.near||c>r.far?null:{distance:c,point:_intersectionPointWorld.clone(),object:e}}function checkBufferGeometryIntersection(e,t,r,o,i,a,n,s,c,m,f,h){_vA.fromBufferAttribute(i,m),_vB.fromBufferAttribute(i,f),_vC.fromBufferAttribute(i,h);var u=e.morphTargetInfluences;if(t.morphTargets&&a&&u){_morphA.set(0,0,0),_morphB.set(0,0,0),_morphC.set(0,0,0);for(var p=0,_=a.length;p<_;p++){var l=u[p],v=a[p];0!==l&&(_tempA.fromBufferAttribute(v,m),_tempB.fromBufferAttribute(v,f),_tempC.fromBufferAttribute(v,h),n?(_morphA.addScaledVector(_tempA,l),_morphB.addScaledVector(_tempB,l),_morphC.addScaledVector(_tempC,l)):(_morphA.addScaledVector(_tempA.sub(_vA),l),_morphB.addScaledVector(_tempB.sub(_vB),l),_morphC.addScaledVector(_tempC.sub(_vC),l)))}_vA.add(_morphA),_vB.add(_morphB),_vC.add(_morphC)}e.isSkinnedMesh&&(e.boneTransform(m,_vA),e.boneTransform(f,_vB),e.boneTransform(h,_vC));var d=checkIntersection(e,t,r,o,_vA,_vB,_vC,_intersectionPoint);if(d){s&&(_uvA.fromBufferAttribute(s,m),_uvB.fromBufferAttribute(s,f),_uvC.fromBufferAttribute(s,h),d.uv=Triangle.getUV(_intersectionPoint,_vA,_vB,_vC,_uvA,_uvB,_uvC,new Vector2)),c&&(_uvA.fromBufferAttribute(c,m),_uvB.fromBufferAttribute(c,f),_uvC.fromBufferAttribute(c,h),d.uv2=Triangle.getUV(_intersectionPoint,_vA,_vB,_vC,_uvA,_uvB,_uvC,new Vector2));var g=new Face3(m,f,h);Triangle.getNormal(_vA,_vB,_vC,g.normal),d.face=g}return d}Mesh.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Mesh,isMesh:!0,copy:function(e){return Object3D.prototype.copy.call(this,e),void 0!==e.morphTargetInfluences&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),void 0!==e.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this},updateMorphTargets:function(){var e,t,r,o=this.geometry;if(o.isBufferGeometry){var i=o.morphAttributes,a=Object.keys(i);if(a.length>0){var n=i[a[0]];if(void 0!==n)for(this.morphTargetInfluences=[],this.morphTargetDictionary={},e=0,t=n.length;e<t;e++)r=n[e].name||String(e),this.morphTargetInfluences.push(0),this.morphTargetDictionary[r]=e}}else{var s=o.morphTargets;void 0!==s&&s.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},raycast:function(e,t){var r,o=this.geometry,i=this.material,a=this.matrixWorld;if(void 0!==i&&(null===o.boundingSphere&&o.computeBoundingSphere(),_sphere.copy(o.boundingSphere),_sphere.applyMatrix4(a),!1!==e.ray.intersectsSphere(_sphere)&&(_inverseMatrix.getInverse(a),_ray.copy(e.ray).applyMatrix4(_inverseMatrix),null===o.boundingBox||!1!==_ray.intersectsBox(o.boundingBox))))if(o.isBufferGeometry){var n,s,c,m,f,h,u,p,_,l=o.index,v=o.attributes.position,d=o.morphAttributes.position,g=o.morphTargetsRelative,y=o.attributes.uv,B=o.attributes.uv2,A=o.groups,b=o.drawRange;if(null!==l)if(Array.isArray(i))for(m=0,h=A.length;m<h;m++)for(_=i[(p=A[m]).materialIndex],f=Math.max(p.start,b.start),u=Math.min(p.start+p.count,b.start+b.count);f<u;f+=3)n=l.getX(f),s=l.getX(f+1),c=l.getX(f+2),(r=checkBufferGeometryIntersection(this,_,e,_ray,v,d,g,y,B,n,s,c))&&(r.faceIndex=Math.floor(f/3),r.face.materialIndex=p.materialIndex,t.push(r));else for(m=Math.max(0,b.start),h=Math.min(l.count,b.start+b.count);m<h;m+=3)n=l.getX(m),s=l.getX(m+1),c=l.getX(m+2),(r=checkBufferGeometryIntersection(this,i,e,_ray,v,d,g,y,B,n,s,c))&&(r.faceIndex=Math.floor(m/3),t.push(r));else if(void 0!==v)if(Array.isArray(i))for(m=0,h=A.length;m<h;m++)for(_=i[(p=A[m]).materialIndex],f=Math.max(p.start,b.start),u=Math.min(p.start+p.count,b.start+b.count);f<u;f+=3)(r=checkBufferGeometryIntersection(this,_,e,_ray,v,d,g,y,B,n=f,s=f+1,c=f+2))&&(r.faceIndex=Math.floor(f/3),r.face.materialIndex=p.materialIndex,t.push(r));else for(m=Math.max(0,b.start),h=Math.min(v.count,b.start+b.count);m<h;m+=3)(r=checkBufferGeometryIntersection(this,i,e,_ray,v,d,g,y,B,n=m,s=m+1,c=m+2))&&(r.faceIndex=Math.floor(m/3),t.push(r))}else if(o.isGeometry){var M,x,T,V,I=Array.isArray(i),w=o.vertices,C=o.faces,j=o.faceVertexUvs[0];j.length>0&&(V=j);for(var S=0,G=C.length;S<G;S++){var k=C[S],D=I?i[k.materialIndex]:i;if(void 0!==D&&(M=w[k.a],x=w[k.b],T=w[k.c],r=checkIntersection(this,D,e,_ray,M,x,T,_intersectionPoint))){if(V&&V[S]){var P=V[S];_uvA.copy(P[0]),_uvB.copy(P[1]),_uvC.copy(P[2]),r.uv=Triangle.getUV(_intersectionPoint,M,x,T,_uvA,_uvB,_uvC,new Vector2)}r.face=k,r.faceIndex=S,t.push(r)}}}},clone:function(){return new this.constructor(this.geometry,this.material).copy(this)}});export{Mesh};
//# sourceMappingURL=/sm/f1fa1d3c3c9527fc03a578c402d36fcc15ab59eab6824758197f8afd6cd7108d.map