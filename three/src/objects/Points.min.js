/**
 * Minified by jsDelivr using Terser v3.14.1.
 * Original file: /npm/three@0.117.1/src/objects/Points.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{Sphere}from"../math/Sphere.js";import{Ray}from"../math/Ray.js";import{Matrix4}from"../math/Matrix4.js";import{Object3D}from"../core/Object3D.js";import{Vector3}from"../math/Vector3.js";import{PointsMaterial}from"../materials/PointsMaterial.js";import{BufferGeometry}from"../core/BufferGeometry.js";var _inverseMatrix=new Matrix4,_ray=new Ray,_sphere=new Sphere,_position=new Vector3;function Points(t,e){Object3D.call(this),this.type="Points",this.geometry=void 0!==t?t:new BufferGeometry,this.material=void 0!==e?e:new PointsMaterial,this.updateMorphTargets()}function testPoint(t,e,r,i,o,s,a){var n=_ray.distanceSqToPoint(t);if(n<r){var p=new Vector3;_ray.closestPointToPoint(t,p),p.applyMatrix4(i);var h=o.ray.origin.distanceTo(p);if(h<o.near||h>o.far)return;s.push({distance:h,distanceToRay:Math.sqrt(n),point:p,index:e,face:null,object:a})}}Points.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Points,isPoints:!0,raycast:function(t,e){var r=this.geometry,i=this.matrixWorld,o=t.params.Points.threshold;if(null===r.boundingSphere&&r.computeBoundingSphere(),_sphere.copy(r.boundingSphere),_sphere.applyMatrix4(i),_sphere.radius+=o,!1!==t.ray.intersectsSphere(_sphere)){_inverseMatrix.getInverse(i),_ray.copy(t.ray).applyMatrix4(_inverseMatrix);var s=o/((this.scale.x+this.scale.y+this.scale.z)/3),a=s*s;if(r.isBufferGeometry){var n=r.index,p=r.attributes.position.array;if(null!==n)for(var h=n.array,c=0,m=h.length;c<m;c++){var f=h[c];_position.fromArray(p,3*f),testPoint(_position,f,a,i,t,e,this)}else{c=0;for(var y=p.length/3;c<y;c++)_position.fromArray(p,3*c),testPoint(_position,c,a,i,t,e,this)}}else{var l=r.vertices;for(c=0,y=l.length;c<y;c++)testPoint(l[c],c,a,i,t,e,this)}}},updateMorphTargets:function(){var t,e,r,i=this.geometry;if(i.isBufferGeometry){var o=i.morphAttributes,s=Object.keys(o);if(s.length>0){var a=o[s[0]];if(void 0!==a)for(this.morphTargetInfluences=[],this.morphTargetDictionary={},t=0,e=a.length;t<e;t++)r=a[t].name||String(t),this.morphTargetInfluences.push(0),this.morphTargetDictionary[r]=t}}else{var n=i.morphTargets;void 0!==n&&n.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}},clone:function(){return new this.constructor(this.geometry,this.material).copy(this)}});export{Points};
//# sourceMappingURL=/sm/5caae1c26b22d22bc19f3b57ecc72a58735f2a57501e86f196e53fcf29fbaa50.map