/**
 * Minified by jsDelivr using Terser v3.14.1.
 * Original file: /npm/three@0.117.1/src/core/Geometry.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{EventDispatcher}from"./EventDispatcher.js";import{Face3}from"./Face3.js";import{Matrix3}from"../math/Matrix3.js";import{Sphere}from"../math/Sphere.js";import{Box3}from"../math/Box3.js";import{Vector3}from"../math/Vector3.js";import{Matrix4}from"../math/Matrix4.js";import{Vector2}from"../math/Vector2.js";import{Color}from"../math/Color.js";import{Object3D}from"./Object3D.js";import{MathUtils}from"../math/MathUtils.js";var _geometryId=0,_m1=new Matrix4,_obj=new Object3D,_offset=new Vector3;function Geometry(){Object.defineProperty(this,"id",{value:_geometryId+=2}),this.uuid=MathUtils.generateUUID(),this.name="",this.type="Geometry",this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.elementsNeedUpdate=!1,this.verticesNeedUpdate=!1,this.uvsNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.lineDistancesNeedUpdate=!1,this.groupsNeedUpdate=!1}Geometry.prototype=Object.assign(Object.create(EventDispatcher.prototype),{constructor:Geometry,isGeometry:!0,applyMatrix4:function(e){for(var t=(new Matrix3).getNormalMatrix(e),r=0,o=this.vertices.length;r<o;r++){this.vertices[r].applyMatrix4(e)}for(r=0,o=this.faces.length;r<o;r++){var s=this.faces[r];s.normal.applyMatrix3(t).normalize();for(var i=0,a=s.vertexNormals.length;i<a;i++)s.vertexNormals[i].applyMatrix3(t).normalize()}return null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this.verticesNeedUpdate=!0,this.normalsNeedUpdate=!0,this},rotateX:function(e){return _m1.makeRotationX(e),this.applyMatrix4(_m1),this},rotateY:function(e){return _m1.makeRotationY(e),this.applyMatrix4(_m1),this},rotateZ:function(e){return _m1.makeRotationZ(e),this.applyMatrix4(_m1),this},translate:function(e,t,r){return _m1.makeTranslation(e,t,r),this.applyMatrix4(_m1),this},scale:function(e,t,r){return _m1.makeScale(e,t,r),this.applyMatrix4(_m1),this},lookAt:function(e){return _obj.lookAt(e),_obj.updateMatrix(),this.applyMatrix4(_obj.matrix),this},fromBufferGeometry:function(e){var t=this,r=null!==e.index?e.index.array:void 0,o=e.attributes;if(void 0===o.position)return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),this;var s=o.position.array,i=void 0!==o.normal?o.normal.array:void 0,a=void 0!==o.color?o.color.array:void 0,n=void 0!==o.uv?o.uv.array:void 0,h=void 0!==o.uv2?o.uv2.array:void 0;void 0!==h&&(this.faceVertexUvs[1]=[]);for(var c=0;c<s.length;c+=3)t.vertices.push((new Vector3).fromArray(s,c)),void 0!==a&&t.colors.push((new Color).fromArray(a,c));function l(e,r,o,s){var c=void 0===a?[]:[t.colors[e].clone(),t.colors[r].clone(),t.colors[o].clone()],l=void 0===i?[]:[(new Vector3).fromArray(i,3*e),(new Vector3).fromArray(i,3*r),(new Vector3).fromArray(i,3*o)],m=new Face3(e,r,o,l,c,s);t.faces.push(m),void 0!==n&&t.faceVertexUvs[0].push([(new Vector2).fromArray(n,2*e),(new Vector2).fromArray(n,2*r),(new Vector2).fromArray(n,2*o)]),void 0!==h&&t.faceVertexUvs[1].push([(new Vector2).fromArray(h,2*e),(new Vector2).fromArray(h,2*r),(new Vector2).fromArray(h,2*o)])}var m=e.groups;if(m.length>0)for(c=0;c<m.length;c++)for(var v=m[c],f=v.start,p=f,u=f+v.count;p<u;p+=3)void 0!==r?l(r[p],r[p+1],r[p+2],v.materialIndex):l(p,p+1,p+2,v.materialIndex);else if(void 0!==r)for(c=0;c<r.length;c+=3)l(r[c],r[c+1],r[c+2]);else for(c=0;c<s.length/3;c+=3)l(c,c+1,c+2);return this.computeFaceNormals(),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(_offset).negate(),this.translate(_offset.x,_offset.y,_offset.z),this},normalize:function(){this.computeBoundingSphere();var e=this.boundingSphere.center,t=this.boundingSphere.radius,r=0===t?1:1/t,o=new Matrix4;return o.set(r,0,0,-r*e.x,0,r,0,-r*e.y,0,0,r,-r*e.z,0,0,0,1),this.applyMatrix4(o),this},computeFaceNormals:function(){for(var e=new Vector3,t=new Vector3,r=0,o=this.faces.length;r<o;r++){var s=this.faces[r],i=this.vertices[s.a],a=this.vertices[s.b],n=this.vertices[s.c];e.subVectors(n,a),t.subVectors(i,a),e.cross(t),e.normalize(),s.normal.copy(e)}},computeVertexNormals:function(e){var t,r,o,s,i,a;for(void 0===e&&(e=!0),a=new Array(this.vertices.length),t=0,r=this.vertices.length;t<r;t++)a[t]=new Vector3;if(e){var n,h,c,l=new Vector3,m=new Vector3;for(o=0,s=this.faces.length;o<s;o++)i=this.faces[o],n=this.vertices[i.a],h=this.vertices[i.b],c=this.vertices[i.c],l.subVectors(c,h),m.subVectors(n,h),l.cross(m),a[i.a].add(l),a[i.b].add(l),a[i.c].add(l)}else for(this.computeFaceNormals(),o=0,s=this.faces.length;o<s;o++)a[(i=this.faces[o]).a].add(i.normal),a[i.b].add(i.normal),a[i.c].add(i.normal);for(t=0,r=this.vertices.length;t<r;t++)a[t].normalize();for(o=0,s=this.faces.length;o<s;o++){var v=(i=this.faces[o]).vertexNormals;3===v.length?(v[0].copy(a[i.a]),v[1].copy(a[i.b]),v[2].copy(a[i.c])):(v[0]=a[i.a].clone(),v[1]=a[i.b].clone(),v[2]=a[i.c].clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeFlatVertexNormals:function(){var e,t,r;for(this.computeFaceNormals(),e=0,t=this.faces.length;e<t;e++){var o=(r=this.faces[e]).vertexNormals;3===o.length?(o[0].copy(r.normal),o[1].copy(r.normal),o[2].copy(r.normal)):(o[0]=r.normal.clone(),o[1]=r.normal.clone(),o[2]=r.normal.clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeMorphNormals:function(){var e,t,r,o,s;for(r=0,o=this.faces.length;r<o;r++)for((s=this.faces[r]).__originalFaceNormal?s.__originalFaceNormal.copy(s.normal):s.__originalFaceNormal=s.normal.clone(),s.__originalVertexNormals||(s.__originalVertexNormals=[]),e=0,t=s.vertexNormals.length;e<t;e++)s.__originalVertexNormals[e]?s.__originalVertexNormals[e].copy(s.vertexNormals[e]):s.__originalVertexNormals[e]=s.vertexNormals[e].clone();var i=new Geometry;for(i.faces=this.faces,e=0,t=this.morphTargets.length;e<t;e++){if(!this.morphNormals[e]){this.morphNormals[e]={},this.morphNormals[e].faceNormals=[],this.morphNormals[e].vertexNormals=[];var a=this.morphNormals[e].faceNormals,n=this.morphNormals[e].vertexNormals;for(r=0,o=this.faces.length;r<o;r++)h=new Vector3,c={a:new Vector3,b:new Vector3,c:new Vector3},a.push(h),n.push(c)}var h,c,l=this.morphNormals[e];for(i.vertices=this.morphTargets[e].vertices,i.computeFaceNormals(),i.computeVertexNormals(),r=0,o=this.faces.length;r<o;r++)s=this.faces[r],h=l.faceNormals[r],c=l.vertexNormals[r],h.copy(s.normal),c.a.copy(s.vertexNormals[0]),c.b.copy(s.vertexNormals[1]),c.c.copy(s.vertexNormals[2])}for(r=0,o=this.faces.length;r<o;r++)(s=this.faces[r]).normal=s.__originalFaceNormal,s.vertexNormals=s.__originalVertexNormals},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new Box3),this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new Sphere),this.boundingSphere.setFromPoints(this.vertices)},merge:function(e,t,r){if(e&&e.isGeometry){var o,s=this.vertices.length,i=this.vertices,a=e.vertices,n=this.faces,h=e.faces,c=this.colors,l=e.colors;void 0===r&&(r=0),void 0!==t&&(o=(new Matrix3).getNormalMatrix(t));for(var m=0,v=a.length;m<v;m++){var f=a[m].clone();void 0!==t&&f.applyMatrix4(t),i.push(f)}for(m=0,v=l.length;m<v;m++)c.push(l[m].clone());for(m=0,v=h.length;m<v;m++){var p,u,d,g=h[m],x=g.vertexNormals,N=g.vertexColors;(p=new Face3(g.a+s,g.b+s,g.c+s)).normal.copy(g.normal),void 0!==o&&p.normal.applyMatrix3(o).normalize();for(var y=0,V=x.length;y<V;y++)u=x[y].clone(),void 0!==o&&u.applyMatrix3(o).normalize(),p.vertexNormals.push(u);p.color.copy(g.color);for(y=0,V=N.length;y<V;y++)d=N[y],p.vertexColors.push(d.clone());p.materialIndex=g.materialIndex+r,n.push(p)}for(m=0,v=e.faceVertexUvs.length;m<v;m++){var b=e.faceVertexUvs[m];void 0===this.faceVertexUvs[m]&&(this.faceVertexUvs[m]=[]);for(y=0,V=b.length;y<V;y++){for(var U=b[y],_=[],M=0,w=U.length;M<w;M++)_.push(U[M].clone());this.faceVertexUvs[m].push(_)}}}else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",e)},mergeMesh:function(e){e&&e.isMesh?(e.matrixAutoUpdate&&e.updateMatrix(),this.merge(e.geometry,e.matrix)):console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",e)},mergeVertices:function(){var e,t,r,o,s,i,a,n,h={},c=[],l=[],m=Math.pow(10,4);for(r=0,o=this.vertices.length;r<o;r++)e=this.vertices[r],void 0===h[t=Math.round(e.x*m)+"_"+Math.round(e.y*m)+"_"+Math.round(e.z*m)]?(h[t]=r,c.push(this.vertices[r]),l[r]=c.length-1):l[r]=l[h[t]];var v=[];for(r=0,o=this.faces.length;r<o;r++){(s=this.faces[r]).a=l[s.a],s.b=l[s.b],s.c=l[s.c],i=[s.a,s.b,s.c];for(var f=0;f<3;f++)if(i[f]===i[(f+1)%3]){v.push(r);break}}for(r=v.length-1;r>=0;r--){var p=v[r];for(this.faces.splice(p,1),a=0,n=this.faceVertexUvs.length;a<n;a++)this.faceVertexUvs[a].splice(p,1)}var u=this.vertices.length-c.length;return this.vertices=c,u},setFromPoints:function(e){this.vertices=[];for(var t=0,r=e.length;t<r;t++){var o=e[t];this.vertices.push(new Vector3(o.x,o.y,o.z||0))}return this},sortFacesByMaterialIndex:function(){for(var e=this.faces,t=e.length,r=0;r<t;r++)e[r]._id=r;e.sort(function(e,t){return e.materialIndex-t.materialIndex});var o,s,i=this.faceVertexUvs[0],a=this.faceVertexUvs[1];i&&i.length===t&&(o=[]),a&&a.length===t&&(s=[]);for(r=0;r<t;r++){var n=e[r]._id;o&&o.push(i[n]),s&&s.push(a[n])}o&&(this.faceVertexUvs[0]=o),s&&(this.faceVertexUvs[1]=s)},toJSON:function(){var e={metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),void 0!==this.parameters){var t=this.parameters;for(var r in t)void 0!==t[r]&&(e[r]=t[r]);return e}for(var o=[],s=0;s<this.vertices.length;s++){var i=this.vertices[s];o.push(i.x,i.y,i.z)}var a=[],n=[],h={},c=[],l={},m=[],v={};for(s=0;s<this.faces.length;s++){var f=this.faces[s],p=void 0!==this.faceVertexUvs[0][s],u=f.normal.length()>0,d=f.vertexNormals.length>0,g=1!==f.color.r||1!==f.color.g||1!==f.color.b,x=f.vertexColors.length>0,N=0;if(N=U(N,0,0),N=U(N,1,!0),N=U(N,2,!1),N=U(N,3,p),N=U(N,4,u),N=U(N,5,d),N=U(N,6,g),N=U(N,7,x),a.push(N),a.push(f.a,f.b,f.c),a.push(f.materialIndex),p){var y=this.faceVertexUvs[0][s];a.push(w(y[0]),w(y[1]),w(y[2]))}if(u&&a.push(_(f.normal)),d){var V=f.vertexNormals;a.push(_(V[0]),_(V[1]),_(V[2]))}if(g&&a.push(M(f.color)),x){var b=f.vertexColors;a.push(M(b[0]),M(b[1]),M(b[2]))}}function U(e,t,r){return r?e|1<<t:e&~(1<<t)}function _(e){var t=e.x.toString()+e.y.toString()+e.z.toString();return void 0!==h[t]?h[t]:(h[t]=n.length/3,n.push(e.x,e.y,e.z),h[t])}function M(e){var t=e.r.toString()+e.g.toString()+e.b.toString();return void 0!==l[t]?l[t]:(l[t]=c.length,c.push(e.getHex()),l[t])}function w(e){var t=e.x.toString()+e.y.toString();return void 0!==v[t]?v[t]:(v[t]=m.length/2,m.push(e.x,e.y),v[t])}return e.data={},e.data.vertices=o,e.data.normals=n,c.length>0&&(e.data.colors=c),m.length>0&&(e.data.uvs=[m]),e.data.faces=a,e},clone:function(){return(new Geometry).copy(this)},copy:function(e){var t,r,o,s,i,a;this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.name=e.name;var n=e.vertices;for(t=0,r=n.length;t<r;t++)this.vertices.push(n[t].clone());var h=e.colors;for(t=0,r=h.length;t<r;t++)this.colors.push(h[t].clone());var c=e.faces;for(t=0,r=c.length;t<r;t++)this.faces.push(c[t].clone());for(t=0,r=e.faceVertexUvs.length;t<r;t++){var l=e.faceVertexUvs[t];for(void 0===this.faceVertexUvs[t]&&(this.faceVertexUvs[t]=[]),o=0,s=l.length;o<s;o++){var m=l[o],v=[];for(i=0,a=m.length;i<a;i++){var f=m[i];v.push(f.clone())}this.faceVertexUvs[t].push(v)}}var p=e.morphTargets;for(t=0,r=p.length;t<r;t++){var u={};if(u.name=p[t].name,void 0!==p[t].vertices)for(u.vertices=[],o=0,s=p[t].vertices.length;o<s;o++)u.vertices.push(p[t].vertices[o].clone());if(void 0!==p[t].normals)for(u.normals=[],o=0,s=p[t].normals.length;o<s;o++)u.normals.push(p[t].normals[o].clone());this.morphTargets.push(u)}var d=e.morphNormals;for(t=0,r=d.length;t<r;t++){var g={};if(void 0!==d[t].vertexNormals)for(g.vertexNormals=[],o=0,s=d[t].vertexNormals.length;o<s;o++){var x=d[t].vertexNormals[o],N={};N.a=x.a.clone(),N.b=x.b.clone(),N.c=x.c.clone(),g.vertexNormals.push(N)}if(void 0!==d[t].faceNormals)for(g.faceNormals=[],o=0,s=d[t].faceNormals.length;o<s;o++)g.faceNormals.push(d[t].faceNormals[o].clone());this.morphNormals.push(g)}var y=e.skinWeights;for(t=0,r=y.length;t<r;t++)this.skinWeights.push(y[t].clone());var V=e.skinIndices;for(t=0,r=V.length;t<r;t++)this.skinIndices.push(V[t].clone());var b=e.lineDistances;for(t=0,r=b.length;t<r;t++)this.lineDistances.push(b[t]);var U=e.boundingBox;null!==U&&(this.boundingBox=U.clone());var _=e.boundingSphere;return null!==_&&(this.boundingSphere=_.clone()),this.elementsNeedUpdate=e.elementsNeedUpdate,this.verticesNeedUpdate=e.verticesNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.lineDistancesNeedUpdate=e.lineDistancesNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});export{Geometry};
//# sourceMappingURL=/sm/09e2ced1b0cecc9142680fe464bab41defe5d777872248160455a9e97c4922ce.map