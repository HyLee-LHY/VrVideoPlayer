/**
 * Minified by jsDelivr using Terser v3.14.1.
 * Original file: /npm/three@0.117.1/src/core/BufferGeometry.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{Vector3}from"../math/Vector3.js";import{Box3}from"../math/Box3.js";import{EventDispatcher}from"./EventDispatcher.js";import{BufferAttribute,Float32BufferAttribute,Uint16BufferAttribute,Uint32BufferAttribute}from"./BufferAttribute.js";import{Sphere}from"../math/Sphere.js";import{DirectGeometry}from"./DirectGeometry.js";import{Object3D}from"./Object3D.js";import{Matrix4}from"../math/Matrix4.js";import{Matrix3}from"../math/Matrix3.js";import{MathUtils}from"../math/MathUtils.js";import{arrayMax}from"../utils.js";var _bufferGeometryId=1,_m1=new Matrix4,_obj=new Object3D,_offset=new Vector3,_box=new Box3,_boxMorphTargets=new Box3,_vector=new Vector3;function BufferGeometry(){Object.defineProperty(this,"id",{value:_bufferGeometryId+=2}),this.uuid=MathUtils.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}BufferGeometry.prototype=Object.assign(Object.create(EventDispatcher.prototype),{constructor:BufferGeometry,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(t){Array.isArray(t)?this.index=new(arrayMax(t)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(t,1):this.index=t},getAttribute:function(t){return this.attributes[t]},setAttribute:function(t,e){return this.attributes[t]=e,this},deleteAttribute:function(t){return delete this.attributes[t],this},addGroup:function(t,e,r){this.groups.push({start:t,count:e,materialIndex:void 0!==r?r:0})},clearGroups:function(){this.groups=[]},setDrawRange:function(t,e){this.drawRange.start=t,this.drawRange.count=e},applyMatrix4:function(t){var e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);var r=this.attributes.normal;if(void 0!==r){var o=(new Matrix3).getNormalMatrix(t);r.applyNormalMatrix(o),r.needsUpdate=!0}var i=this.attributes.tangent;return void 0!==i&&(i.transformDirection(t),i.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this},rotateX:function(t){return _m1.makeRotationX(t),this.applyMatrix4(_m1),this},rotateY:function(t){return _m1.makeRotationY(t),this.applyMatrix4(_m1),this},rotateZ:function(t){return _m1.makeRotationZ(t),this.applyMatrix4(_m1),this},translate:function(t,e,r){return _m1.makeTranslation(t,e,r),this.applyMatrix4(_m1),this},scale:function(t,e,r){return _m1.makeScale(t,e,r),this.applyMatrix4(_m1),this},lookAt:function(t){return _obj.lookAt(t),_obj.updateMatrix(),this.applyMatrix4(_obj.matrix),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(_offset).negate(),this.translate(_offset.x,_offset.y,_offset.z),this},setFromObject:function(t){var e=t.geometry;if(t.isPoints||t.isLine){var r=new Float32BufferAttribute(3*e.vertices.length,3),o=new Float32BufferAttribute(3*e.colors.length,3);if(this.setAttribute("position",r.copyVector3sArray(e.vertices)),this.setAttribute("color",o.copyColorsArray(e.colors)),e.lineDistances&&e.lineDistances.length===e.vertices.length){var i=new Float32BufferAttribute(e.lineDistances.length,1);this.setAttribute("lineDistance",i.copyArray(e.lineDistances))}null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone())}else t.isMesh&&e&&e.isGeometry&&this.fromGeometry(e);return this},setFromPoints:function(t){for(var e=[],r=0,o=t.length;r<o;r++){var i=t[r];e.push(i.x,i.y,i.z||0)}return this.setAttribute("position",new Float32BufferAttribute(e,3)),this},updateFromObject:function(t){var e,r=t.geometry;if(t.isMesh){var o=r.__directGeometry;if(!0===r.elementsNeedUpdate&&(o=void 0,r.elementsNeedUpdate=!1),void 0===o)return this.fromGeometry(r);o.verticesNeedUpdate=r.verticesNeedUpdate,o.normalsNeedUpdate=r.normalsNeedUpdate,o.colorsNeedUpdate=r.colorsNeedUpdate,o.uvsNeedUpdate=r.uvsNeedUpdate,o.groupsNeedUpdate=r.groupsNeedUpdate,r.verticesNeedUpdate=!1,r.normalsNeedUpdate=!1,r.colorsNeedUpdate=!1,r.uvsNeedUpdate=!1,r.groupsNeedUpdate=!1,r=o}return!0===r.verticesNeedUpdate&&(void 0!==(e=this.attributes.position)&&(e.copyVector3sArray(r.vertices),e.needsUpdate=!0),r.verticesNeedUpdate=!1),!0===r.normalsNeedUpdate&&(void 0!==(e=this.attributes.normal)&&(e.copyVector3sArray(r.normals),e.needsUpdate=!0),r.normalsNeedUpdate=!1),!0===r.colorsNeedUpdate&&(void 0!==(e=this.attributes.color)&&(e.copyColorsArray(r.colors),e.needsUpdate=!0),r.colorsNeedUpdate=!1),r.uvsNeedUpdate&&(void 0!==(e=this.attributes.uv)&&(e.copyVector2sArray(r.uvs),e.needsUpdate=!0),r.uvsNeedUpdate=!1),r.lineDistancesNeedUpdate&&(void 0!==(e=this.attributes.lineDistance)&&(e.copyArray(r.lineDistances),e.needsUpdate=!0),r.lineDistancesNeedUpdate=!1),r.groupsNeedUpdate&&(r.computeGroups(t.geometry),this.groups=r.groups,r.groupsNeedUpdate=!1),this},fromGeometry:function(t){return t.__directGeometry=(new DirectGeometry).fromGeometry(t),this.fromDirectGeometry(t.__directGeometry)},fromDirectGeometry:function(t){var e=new Float32Array(3*t.vertices.length);if(this.setAttribute("position",new BufferAttribute(e,3).copyVector3sArray(t.vertices)),t.normals.length>0){var r=new Float32Array(3*t.normals.length);this.setAttribute("normal",new BufferAttribute(r,3).copyVector3sArray(t.normals))}if(t.colors.length>0){var o=new Float32Array(3*t.colors.length);this.setAttribute("color",new BufferAttribute(o,3).copyColorsArray(t.colors))}if(t.uvs.length>0){var i=new Float32Array(2*t.uvs.length);this.setAttribute("uv",new BufferAttribute(i,2).copyVector2sArray(t.uvs))}if(t.uvs2.length>0){var n=new Float32Array(2*t.uvs2.length);this.setAttribute("uv2",new BufferAttribute(n,2).copyVector2sArray(t.uvs2))}for(var s in this.groups=t.groups,t.morphTargets){for(var a=[],u=t.morphTargets[s],h=0,d=u.length;h<d;h++){var f=u[h],p=new Float32BufferAttribute(3*f.data.length,3);p.name=f.name,a.push(p.copyVector3sArray(f.data))}this.morphAttributes[s]=a}if(t.skinIndices.length>0){var m=new Float32BufferAttribute(4*t.skinIndices.length,4);this.setAttribute("skinIndex",m.copyVector4sArray(t.skinIndices))}if(t.skinWeights.length>0){var l=new Float32BufferAttribute(4*t.skinWeights.length,4);this.setAttribute("skinWeight",l.copyVector4sArray(t.skinWeights))}return null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),this},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new Box3);var t=this.attributes.position,e=this.morphAttributes.position;if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(var r=0,o=e.length;r<o;r++){var i=e[r];_box.setFromBufferAttribute(i),this.morphTargetsRelative?(_vector.addVectors(this.boundingBox.min,_box.min),this.boundingBox.expandByPoint(_vector),_vector.addVectors(this.boundingBox.max,_box.max),this.boundingBox.expandByPoint(_vector)):(this.boundingBox.expandByPoint(_box.min),this.boundingBox.expandByPoint(_box.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new Sphere);var t=this.attributes.position,e=this.morphAttributes.position;if(t){var r=this.boundingSphere.center;if(_box.setFromBufferAttribute(t),e)for(var o=0,i=e.length;o<i;o++){var n=e[o];_boxMorphTargets.setFromBufferAttribute(n),this.morphTargetsRelative?(_vector.addVectors(_box.min,_boxMorphTargets.min),_box.expandByPoint(_vector),_vector.addVectors(_box.max,_boxMorphTargets.max),_box.expandByPoint(_vector)):(_box.expandByPoint(_boxMorphTargets.min),_box.expandByPoint(_boxMorphTargets.max))}_box.getCenter(r);var s=0;for(o=0,i=t.count;o<i;o++)_vector.fromBufferAttribute(t,o),s=Math.max(s,r.distanceToSquared(_vector));if(e)for(o=0,i=e.length;o<i;o++){n=e[o];for(var a=this.morphTargetsRelative,u=0,h=n.count;u<h;u++)_vector.fromBufferAttribute(n,u),a&&(_offset.fromBufferAttribute(t,u),_vector.add(_offset)),s=Math.max(s,r.distanceToSquared(_vector))}this.boundingSphere.radius=Math.sqrt(s),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}},computeFaceNormals:function(){},computeVertexNormals:function(){var t=this.index,e=this.attributes;if(e.position){var r=e.position.array;if(void 0===e.normal)this.setAttribute("normal",new BufferAttribute(new Float32Array(r.length),3));else for(var o=e.normal.array,i=0,n=o.length;i<n;i++)o[i]=0;var s,a,u,h=e.normal.array,d=new Vector3,f=new Vector3,p=new Vector3,m=new Vector3,l=new Vector3;if(t){var c=t.array;for(i=0,n=t.count;i<n;i+=3)s=3*c[i+0],a=3*c[i+1],u=3*c[i+2],d.fromArray(r,s),f.fromArray(r,a),p.fromArray(r,u),m.subVectors(p,f),l.subVectors(d,f),m.cross(l),h[s]+=m.x,h[s+1]+=m.y,h[s+2]+=m.z,h[a]+=m.x,h[a+1]+=m.y,h[a+2]+=m.z,h[u]+=m.x,h[u+1]+=m.y,h[u+2]+=m.z}else for(i=0,n=r.length;i<n;i+=9)d.fromArray(r,i),f.fromArray(r,i+3),p.fromArray(r,i+6),m.subVectors(p,f),l.subVectors(d,f),m.cross(l),h[i]=m.x,h[i+1]=m.y,h[i+2]=m.z,h[i+3]=m.x,h[i+4]=m.y,h[i+5]=m.z,h[i+6]=m.x,h[i+7]=m.y,h[i+8]=m.z;this.normalizeNormals(),e.normal.needsUpdate=!0}},merge:function(t,e){if(t&&t.isBufferGeometry){void 0===e&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));var r=this.attributes;for(var o in r)if(void 0!==t.attributes[o])for(var i=r[o].array,n=t.attributes[o],s=n.array,a=n.itemSize*e,u=Math.min(s.length,i.length-a),h=0,d=a;h<u;h++,d++)i[d]=s[h];return this}console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t)},normalizeNormals:function(){for(var t=this.attributes.normal,e=0,r=t.count;e<r;e++)_vector.x=t.getX(e),_vector.y=t.getY(e),_vector.z=t.getZ(e),_vector.normalize(),t.setXYZ(e,_vector.x,_vector.y,_vector.z)},toNonIndexed:function(){function t(t,e){for(var r=t.array,o=t.itemSize,i=t.normalized,n=new r.constructor(e.length*o),s=0,a=0,u=0,h=e.length;u<h;u++){s=e[u]*o;for(var d=0;d<o;d++)n[a++]=r[s++]}return new BufferAttribute(n,o,i)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),this;var e=new BufferGeometry,r=this.index.array,o=this.attributes;for(var i in o){var n=t(o[i],r);e.setAttribute(i,n)}var s=this.morphAttributes;for(i in s){for(var a=[],u=s[i],h=0,d=u.length;h<d;h++){n=t(u[h],r);a.push(n)}e.morphAttributes[i]=a}e.morphTargetsRelative=this.morphTargetsRelative;for(var f=this.groups,p=(h=0,f.length);h<p;h++){var m=f[h];e.addGroup(m.start,m.count,m.materialIndex)}return e},toJSON:function(){var t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){var e=this.parameters;for(var r in e)void 0!==e[r]&&(t[r]=e[r]);return t}t.data={attributes:{}};var o=this.index;null!==o&&(t.data.index={type:o.array.constructor.name,array:Array.prototype.slice.call(o.array)});var i=this.attributes;for(var r in i){var n=(p=i[r]).toJSON();""!==p.name&&(n.name=p.name),t.data.attributes[r]=n}var s={},a=!1;for(var r in this.morphAttributes){for(var u=this.morphAttributes[r],h=[],d=0,f=u.length;d<f;d++){var p;n=(p=u[d]).toJSON();""!==p.name&&(n.name=p.name),h.push(n)}h.length>0&&(s[r]=h,a=!0)}a&&(t.data.morphAttributes=s,t.data.morphTargetsRelative=this.morphTargetsRelative);var m=this.groups;m.length>0&&(t.data.groups=JSON.parse(JSON.stringify(m)));var l=this.boundingSphere;return null!==l&&(t.data.boundingSphere={center:l.center.toArray(),radius:l.radius}),t},clone:function(){return(new BufferGeometry).copy(this)},copy:function(t){var e,r,o;this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.name=t.name;var i=t.index;null!==i&&this.setIndex(i.clone());var n=t.attributes;for(e in n){var s=n[e];this.setAttribute(e,s.clone())}var a=t.morphAttributes;for(e in a){var u=[],h=a[e];for(r=0,o=h.length;r<o;r++)u.push(h[r].clone());this.morphAttributes[e]=u}this.morphTargetsRelative=t.morphTargetsRelative;var d=t.groups;for(r=0,o=d.length;r<o;r++){var f=d[r];this.addGroup(f.start,f.count,f.materialIndex)}var p=t.boundingBox;null!==p&&(this.boundingBox=p.clone());var m=t.boundingSphere;return null!==m&&(this.boundingSphere=m.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});export{BufferGeometry};
//# sourceMappingURL=/sm/738eaa9f8969145a3922623b329ba28c7146f78de3d98aead050f16a23a11575.map